/*!
* MDB5
* Core Version: FREE 7.0.0
* Bite Version: PRO 7.0.0
* This is an MDB Bite package - it contains only a single component from the PRO version and the entire core from the free version.
* Please keep in mind that you will not receive separate updates for this single-component package. You can download the Free Core updates from mdbootstrap.com version, but PRO component updates are available only in MDB PRO subscription tiers. If you would like to upgrade to get updates please reach out to contact@mdbootstrap.com
*
*
* Copyright: Material Design for Bootstrap
* https://mdbootstrap.com/
*
* Read the license: https://mdbootstrap.com/general/license/
*
*
* Documentation: https://mdbootstrap.com/docs/standard/
*
* Support: https://mdbootstrap.com/support/
*
* Contact: contact@mdbootstrap.com
*
*/
var Ja = Object.defineProperty;
var tl = (i, t, e) => t in i ? Ja(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var pt = (i, t, e) => (tl(i, typeof t != "symbol" ? t + "" : t, e), e);
const Vi = (() => {
  const i = {};
  let t = 1;
  return {
    set(e, s, n) {
      typeof e[s] > "u" && (e[s] = {
        key: s,
        id: t
      }, t++), i[e[s].id] = n;
    },
    get(e, s) {
      if (!e || typeof e[s] > "u")
        return null;
      const n = e[s];
      return n.key === s ? i[n.id] : null;
    },
    delete(e, s) {
      if (typeof e[s] > "u")
        return;
      const n = e[s];
      n.key === s && (delete i[n.id], delete e[s]);
    }
  };
})(), ct = {
  setData(i, t, e) {
    Vi.set(i, t, e);
  },
  getData(i, t) {
    return Vi.get(i, t);
  },
  removeData(i, t) {
    Vi.delete(i, t);
  }
}, el = 1e6, il = (i) => i == null ? `${i}` : {}.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(), Vt = (i) => {
  do
    i += Math.floor(Math.random() * el);
  while (document.getElementById(i));
  return i;
}, cr = (i) => {
  let t = i.getAttribute("data-mdb-target");
  if (!t || t === "#") {
    const e = i.getAttribute("href");
    t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, gi = (i) => {
  const t = cr(i);
  return t && document.querySelector(t) ? t : null;
}, ne = (i) => {
  const t = cr(i);
  return t ? document.querySelector(t) : null;
}, dr = (i) => !i || typeof i != "object" ? !1 : (typeof i.jquery < "u" && (i = i[0]), typeof i.nodeType < "u"), rn = (i) => dr(i) ? i.jquery ? i[0] : i : typeof i == "string" && i.length > 0 ? document.querySelector(i) : null, De = (i, t, e) => {
  Object.keys(e).forEach((s) => {
    const n = e[s], o = t[s], r = o && dr(o) ? "element" : il(o);
    if (!new RegExp(n).test(r))
      throw new Error(
        `${i.toUpperCase()}: Option "${s}" provided type "${r}" but expected type "${n}".`
      );
  });
}, Ai = (i) => {
  if (!i)
    return !1;
  if (i.style && i.parentNode && i.parentNode.style) {
    const t = getComputedStyle(i), e = getComputedStyle(i.parentNode);
    return t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, hr = (i) => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains("disabled") ? !0 : typeof i.disabled < "u" ? i.disabled : i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false", ur = () => {
  const { jQuery: i } = window;
  return i && !document.body.hasAttribute("data-mdb-no-jquery") ? i : null;
}, pr = (i) => {
  document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", i) : i();
}, Kt = document.documentElement.dir === "rtl", P = (i) => document.createElement(i), sl = (i) => {
  pr(() => {
    const t = ur();
    if (t) {
      const e = i.NAME, s = t.fn[e];
      t.fn[e] = i.jQueryInterface, t.fn[e].Constructor = i, t.fn[e].noConflict = () => (t.fn[e] = s, i.jQueryInterface);
    }
  });
}, Hi = ur(), nl = /[^.]*(?=\..*)\.|.*/, fr = /\..*/, ol = /::\d+$/, Bi = {};
let an = 1;
const rl = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, _r = [
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
];
function mr(i, t) {
  return t && `${t}::${an++}` || i.uidEvent || an++;
}
function gr(i) {
  const t = mr(i);
  return i.uidEvent = t, Bi[t] = Bi[t] || {}, Bi[t];
}
function al(i, t) {
  return function e(s) {
    return s.delegateTarget = i, e.oneOff && u.off(i, s.type, t), t.apply(i, [s]);
  };
}
function ll(i, t, e) {
  return function s(n) {
    const o = i.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (let a = o.length; a--; "")
        if (o[a] === r)
          return n.delegateTarget = r, s.oneOff && u.off(i, n.type, e), e.apply(r, [n]);
    return null;
  };
}
function br(i, t, e = null) {
  const s = Object.keys(i);
  for (let n = 0, o = s.length; n < o; n++) {
    const r = i[s[n]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function Er(i, t, e) {
  const s = typeof t == "string", n = s ? e : t;
  let o = i.replace(fr, "");
  const r = rl[o];
  return r && (o = r), _r.indexOf(o) > -1 || (o = i), [s, n, o];
}
function ln(i, t, e, s, n) {
  if (typeof t != "string" || !i)
    return;
  e || (e = s, s = null);
  const [o, r, a] = Er(
    t,
    e,
    s
  ), l = gr(i), d = l[a] || (l[a] = {}), h = br(d, r, o ? e : null);
  if (h) {
    h.oneOff = h.oneOff && n;
    return;
  }
  const f = mr(r, t.replace(nl, "")), m = o ? ll(i, e, s) : al(i, e);
  m.delegationSelector = o ? e : null, m.originalHandler = r, m.oneOff = n, m.uidEvent = f, d[f] = m, i.addEventListener(a, m, o);
}
function Es(i, t, e, s, n) {
  const o = br(t[e], s, n);
  o && (i.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function cl(i, t, e, s) {
  const n = t[e] || {};
  Object.keys(n).forEach((o) => {
    if (o.indexOf(s) > -1) {
      const r = n[o];
      Es(i, t, e, r.originalHandler, r.delegationSelector);
    }
  });
}
const u = {
  on(i, t, e, s) {
    ln(i, t, e, s, !1);
  },
  one(i, t, e, s) {
    ln(i, t, e, s, !0);
  },
  extend(i, t, e) {
    t.forEach((s) => {
      u.on(i, `${s.name}.bs.${e}`, (n) => {
        const o = {};
        s.parametersToCopy && s.parametersToCopy.forEach((a) => {
          o[a] = n[a];
        }), u.trigger(
          i,
          `${s.name}.mdb.${e}`,
          o
        ).defaultPrevented && n.preventDefault();
      });
    });
  },
  off(i, t, e, s) {
    if (typeof t != "string" || !i)
      return;
    const [n, o, r] = Er(
      t,
      e,
      s
    ), a = r !== t, l = gr(i), d = t.charAt(0) === ".";
    if (typeof o < "u") {
      if (!l || !l[r])
        return;
      Es(i, l, r, o, n ? e : null);
      return;
    }
    d && Object.keys(l).forEach((f) => {
      cl(i, l, f, t.slice(1));
    });
    const h = l[r] || {};
    Object.keys(h).forEach((f) => {
      const m = f.replace(ol, "");
      if (!a || t.indexOf(m) > -1) {
        const _ = h[f];
        Es(i, l, r, _.originalHandler, _.delegationSelector);
      }
    });
  },
  trigger(i, t, e) {
    if (typeof t != "string" || !i)
      return null;
    const s = t.replace(fr, ""), n = t !== s, o = _r.indexOf(s) > -1;
    let r, a = !0, l = !0, d = !1, h = null;
    return n && Hi && (r = Hi.Event(t, e), Hi(i).trigger(r), a = !r.isPropagationStopped(), l = !r.isImmediatePropagationStopped(), d = r.isDefaultPrevented()), o ? (h = document.createEvent("HTMLEvents"), h.initEvent(s, a, !0)) : h = new CustomEvent(t, {
      bubbles: a,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((f) => {
      Object.defineProperty(h, f, {
        get() {
          return e[f];
        }
      });
    }), d && h.preventDefault(), l && i.dispatchEvent(h), h.defaultPrevented && typeof r < "u" && r.preventDefault(), h;
  }
}, Ut = {
  on(i, t, e, s) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      u.on(i, n[o], e, s);
  },
  off(i, t, e, s) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      u.off(i, n[o], e, s);
  }
};
function cn(i) {
  return i === "true" ? !0 : i === "false" ? !1 : i === Number(i).toString() ? Number(i) : i === "" || i === "null" ? null : i;
}
function Fi(i) {
  return i.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const c = {
  setDataAttribute(i, t, e) {
    i.setAttribute(`data-mdb-${Fi(t)}`, e);
  },
  removeDataAttribute(i, t) {
    i.removeAttribute(`data-mdb-${Fi(t)}`);
  },
  getDataAttributes(i) {
    if (!i)
      return {};
    const t = {
      ...i.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("mdb")).forEach((e) => {
      let s = e.replace(/^mdb/, "");
      s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = cn(t[e]);
    }), t;
  },
  getDataAttribute(i, t) {
    return cn(i.getAttribute(`data-mdb-${Fi(t)}`));
  },
  offset(i) {
    const t = i.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(i) {
    return {
      top: i.offsetTop,
      left: i.offsetLeft
    };
  },
  style(i, t) {
    Object.assign(i.style, t);
  },
  toggleClass(i, t) {
    i && (i.classList.contains(t) ? i.classList.remove(t) : i.classList.add(t));
  },
  addClass(i, t) {
    i.classList.contains(t) || i.classList.add(t);
  },
  addStyle(i, t) {
    Object.keys(t).forEach((e) => {
      i.style[e] = t[e];
    });
  },
  removeClass(i, t) {
    i.classList.contains(t) && i.classList.remove(t);
  },
  hasClass(i, t) {
    return i.classList.contains(t);
  }
}, dl = 3, p = {
  closest(i, t) {
    return i.closest(t);
  },
  matches(i, t) {
    return i.matches(t);
  },
  find(i, t = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(t, i));
  },
  findOne(i, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, i);
  },
  children(i, t) {
    return [].concat(...i.children).filter((s) => s.matches(t));
  },
  parents(i, t) {
    const e = [];
    let s = i.parentNode;
    for (; s && s.nodeType === Node.ELEMENT_NODE && s.nodeType !== dl; )
      this.matches(s, t) && e.push(s), s = s.parentNode;
    return e;
  },
  prev(i, t) {
    let e = i.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(i, t) {
    let e = i.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  }
}, yt = /* @__PURE__ */ new Map(), Wi = {
  set(i, t, e) {
    yt.has(i) || yt.set(i, /* @__PURE__ */ new Map());
    const s = yt.get(i);
    if (!s.has(t) && s.size !== 0) {
      console.error(
        `Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`
      );
      return;
    }
    s.set(t, e);
  },
  get(i, t) {
    return yt.has(i) && yt.get(i).get(t) || null;
  },
  remove(i, t) {
    if (!yt.has(i))
      return;
    const e = yt.get(i);
    e.delete(t), e.size === 0 && yt.delete(i);
  }
}, hl = 1e6, ul = 1e3, vs = "transitionend", vr = (i) => (i && window.CSS && window.CSS.escape && (i = i.replace(/#([^\s"#']+)/g, (t, e) => `#${CSS.escape(e)}`)), i), pl = (i) => i == null ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(), fl = (i) => {
  do
    i += Math.floor(Math.random() * hl);
  while (document.getElementById(i));
  return i;
}, _l = (i) => {
  if (!i)
    return 0;
  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(i);
  const s = Number.parseFloat(t), n = Number.parseFloat(e);
  return !s && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * ul);
}, Tr = (i) => {
  i.dispatchEvent(new Event(vs));
}, Tt = (i) => !i || typeof i != "object" ? !1 : (typeof i.jquery < "u" && (i = i[0]), typeof i.nodeType < "u"), $t = (i) => Tt(i) ? i.jquery ? i[0] : i : typeof i == "string" && i.length > 0 ? document.querySelector(vr(i)) : null, yi = (i) => {
  if (!Tt(i) || i.getClientRects().length === 0)
    return !1;
  const t = getComputedStyle(i).getPropertyValue("visibility") === "visible", e = i.closest("details:not([open])");
  if (!e)
    return t;
  if (e !== i) {
    const s = i.closest("summary");
    if (s && s.parentNode !== e || s === null)
      return !1;
  }
  return t;
}, oe = (i) => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains("disabled") ? !0 : typeof i.disabled < "u" ? i.disabled : i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false", Cr = (i) => {
  if (!document.documentElement.attachShadow)
    return null;
  if (typeof i.getRootNode == "function") {
    const t = i.getRootNode();
    return t instanceof ShadowRoot ? t : null;
  }
  return i instanceof ShadowRoot ? i : i.parentNode ? Cr(i.parentNode) : null;
}, bi = () => {
}, $e = (i) => {
  i.offsetHeight;
}, ml = () => window.jQuery && !document.body.hasAttribute("data-mdb-no-jquery") ? window.jQuery : null, at = () => document.documentElement.dir === "rtl", J = (i, t = [], e = i) => typeof i == "function" ? i(...t) : e, Ar = (i, t, e = !0) => {
  if (!e) {
    J(i);
    return;
  }
  const s = 5, n = _l(t) + s;
  let o = !1;
  const r = ({ target: a }) => {
    a === t && (o = !0, t.removeEventListener(vs, r), J(i));
  };
  t.addEventListener(vs, r), setTimeout(() => {
    o || Tr(t);
  }, n);
}, Is = (i, t, e, s) => {
  const n = i.length;
  let o = i.indexOf(t);
  return o === -1 ? !e && s ? i[n - 1] : i[0] : (o += e ? 1 : -1, s && (o = (o + n) % n), i[Math.max(0, Math.min(o, n - 1))]);
}, gl = /[^.]*(?=\..*)\.|.*/, bl = /\..*/, El = /::\d+$/, Yi = {};
let dn = 1;
const yr = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, vl = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function Or(i, t) {
  return t && `${t}::${dn++}` || i.uidEvent || dn++;
}
function Sr(i) {
  const t = Or(i);
  return i.uidEvent = t, Yi[t] = Yi[t] || {}, Yi[t];
}
function Tl(i, t) {
  return function e(s) {
    return xs(s, { delegateTarget: i }), e.oneOff && T.off(i, s.type, t), t.apply(i, [s]);
  };
}
function Cl(i, t, e) {
  return function s(n) {
    const o = i.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (const a of o)
        if (a === r)
          return xs(n, { delegateTarget: r }), s.oneOff && T.off(i, n.type, t, e), e.apply(r, [n]);
  };
}
function wr(i, t, e = null) {
  return Object.values(i).find(
    (s) => s.callable === t && s.delegationSelector === e
  );
}
function Nr(i, t, e) {
  const s = typeof t == "string", n = s ? e : t || e;
  let o = Dr(i);
  return vl.has(o) || (o = i), [s, n, o];
}
function hn(i, t, e, s, n) {
  if (typeof t != "string" || !i)
    return;
  let [o, r, a] = Nr(
    t,
    e,
    s
  );
  t in yr && (r = ((g) => function(b) {
    if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))
      return g.call(this, b);
  })(r));
  const l = Sr(i), d = l[a] || (l[a] = {}), h = wr(d, r, o ? e : null);
  if (h) {
    h.oneOff = h.oneOff && n;
    return;
  }
  const f = Or(r, t.replace(gl, "")), m = o ? Cl(i, e, r) : Tl(i, r);
  m.delegationSelector = o ? e : null, m.callable = r, m.oneOff = n, m.uidEvent = f, d[f] = m, i.addEventListener(a, m, o);
}
function Ts(i, t, e, s, n) {
  const o = wr(t[e], s, n);
  o && (i.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function Al(i, t, e, s) {
  const n = t[e] || {};
  for (const [o, r] of Object.entries(n))
    o.includes(s) && Ts(i, t, e, r.callable, r.delegationSelector);
}
function Dr(i) {
  return i = i.replace(bl, ""), yr[i] || i;
}
const T = {
  on(i, t, e, s) {
    hn(i, t, e, s, !1);
  },
  one(i, t, e, s) {
    hn(i, t, e, s, !0);
  },
  off(i, t, e, s) {
    if (typeof t != "string" || !i)
      return;
    const [n, o, r] = Nr(
      t,
      e,
      s
    ), a = r !== t, l = Sr(i), d = l[r] || {}, h = t.startsWith(".");
    if (typeof o < "u") {
      if (!Object.keys(d).length)
        return;
      Ts(i, l, r, o, n ? e : null);
      return;
    }
    if (h)
      for (const f of Object.keys(l))
        Al(i, l, f, t.slice(1));
    for (const [f, m] of Object.entries(d)) {
      const _ = f.replace(El, "");
      (!a || t.includes(_)) && Ts(i, l, r, m.callable, m.delegationSelector);
    }
  },
  trigger(i, t, e) {
    if (typeof t != "string" || !i)
      return null;
    const s = ml(), n = Dr(t), o = t !== n;
    let r = null, a = !0, l = !0, d = !1;
    o && s && (r = s.Event(t, e), s(i).trigger(r), a = !r.isPropagationStopped(), l = !r.isImmediatePropagationStopped(), d = r.isDefaultPrevented());
    const h = xs(new Event(t, { bubbles: a, cancelable: !0 }), e);
    return d && h.preventDefault(), l && i.dispatchEvent(h), h.defaultPrevented && r && r.preventDefault(), h;
  }
};
function xs(i, t = {}) {
  for (const [e, s] of Object.entries(t))
    try {
      i[e] = s;
    } catch {
      Object.defineProperty(i, e, {
        configurable: !0,
        get() {
          return s;
        }
      });
    }
  return i;
}
function un(i) {
  if (i === "true")
    return !0;
  if (i === "false")
    return !1;
  if (i === Number(i).toString())
    return Number(i);
  if (i === "" || i === "null")
    return null;
  if (typeof i != "string")
    return i;
  try {
    return JSON.parse(decodeURIComponent(i));
  } catch {
    return i;
  }
}
function ji(i) {
  return i.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const Nt = {
  setDataAttribute(i, t, e) {
    i.setAttribute(`data-mdb-${ji(t)}`, e);
  },
  removeDataAttribute(i, t) {
    i.removeAttribute(`data-mdb-${ji(t)}`);
  },
  getDataAttributes(i) {
    if (!i)
      return {};
    const t = {}, e = Object.keys(i.dataset).filter(
      (s) => s.startsWith("mdb") && !s.startsWith("mdbConfig")
    );
    for (const s of e) {
      let n = s.replace(/^mdb/, "");
      n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = un(i.dataset[s]);
    }
    return t;
  },
  getDataAttribute(i, t) {
    return un(i.getAttribute(`data-mdb-${ji(t)}`));
  }
};
class Me {
  // Getters
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(t) {
    return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
  }
  _configAfterMerge(t) {
    return t;
  }
  _mergeConfigObj(t, e) {
    const s = Tt(e) ? Nt.getDataAttribute(e, "config") : {};
    return {
      ...this.constructor.Default,
      ...typeof s == "object" ? s : {},
      ...Tt(e) ? Nt.getDataAttributes(e) : {},
      ...typeof t == "object" ? t : {}
    };
  }
  _typeCheckConfig(t, e = this.constructor.DefaultType) {
    for (const [s, n] of Object.entries(e)) {
      const o = t[s], r = Tt(o) ? "element" : pl(o);
      if (!new RegExp(n).test(r))
        throw new TypeError(
          `${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${r}" but expected type "${n}".`
        );
    }
  }
}
const yl = "5.3.2";
let ht = class extends Me {
  constructor(t, e) {
    super(), t = $t(t), t && (this._element = t, this._config = this._getConfig(e), Wi.set(this._element, this.constructor.DATA_KEY, this));
  }
  // Public
  dispose() {
    Wi.remove(this._element, this.constructor.DATA_KEY), T.off(this._element, this.constructor.EVENT_KEY);
    for (const t of Object.getOwnPropertyNames(this))
      this[t] = null;
  }
  _queueCallback(t, e, s = !0) {
    Ar(t, e, s);
  }
  _getConfig(t) {
    return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
  }
  // Static
  static getInstance(t) {
    return Wi.get($t(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get VERSION() {
    return yl;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(t) {
    return `${t}${this.EVENT_KEY}`;
  }
};
const Ol = "button", Sl = "active";
let wl = class $r extends ht {
  // Getters
  static get NAME() {
    return Ol;
  }
  // Public
  toggle() {
    this._element.setAttribute("aria-pressed", this._element.classList.toggle(Sl));
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = $r.getOrCreateInstance(this);
      t === "toggle" && e[t]();
    });
  }
};
const pn = (() => {
  const i = [];
  return {
    set(t) {
      i.push(t);
    },
    get(t) {
      return i.includes(t);
    }
  };
})(), Ei = {
  set(i) {
    pn.set(i);
  },
  get(i) {
    return pn.get(i);
  }
}, Nl = (i) => Ei.get(i), Y = (i) => {
  Nl(i.NAME) || Mr(i, !0);
}, Mr = (i, t = !1) => {
  if (!i || Ei.get(i.NAME))
    return;
  Ei.set(i.NAME);
  const e = Qt[i.NAME] || null, s = (e == null ? void 0 : e.isToggler) || !1;
  if (sl(i), e != null && e.advanced) {
    e.advanced(i, e == null ? void 0 : e.selector);
    return;
  }
  if (s) {
    e.callback(i, e == null ? void 0 : e.selector);
    return;
  }
  t || p.find(e == null ? void 0 : e.selector).forEach((n) => {
    let o = i.getInstance(n);
    o || (o = new i(n), e != null && e.onInit && o[e.onInit]());
  });
};
let Qt;
class Dl {
  constructor(t) {
    pt(this, "init", (t) => {
      t.forEach((e) => Mr(e));
    });
    pt(this, "initMDB", (t, e = !1) => {
      const s = Object.keys(Qt).map((n) => {
        if (!!document.querySelector(Qt[n].selector)) {
          const r = t[Qt[n].name];
          return !r && !Ei.get(n) && e && console.warn(
            `Please import ${Qt[n].name} from "MDB" package and add it to a object parameter inside "initMDB" function`
          ), r;
        }
        return null;
      });
      this.init(s);
    });
    Qt = t;
  }
}
const Lr = "button", Cs = `mdb.${Lr}`, Le = `.${Cs}`, fn = `click${Le}`, zt = "transitionend", _n = "mouseenter", mn = "mouseleave", $l = `hide${Le}`, Ml = `hidden${Le}`, Ll = `show${Le}`, kl = `shown${Le}`, gn = "active", Il = "shown", Be = "fixed-action-btn", xl = ".fixed-action-btn:not(.smooth-scroll) > .btn-floating", Pl = "ul .btn", Rl = "ul";
class kr extends wl {
  constructor(t) {
    super(t), this._fn = {}, this._element && (ct.setData(this._element, Cs, this), this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor));
  }
  // Static
  static get NAME() {
    return Lr;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = ct.getData(this, Cs);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new kr(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
  // Getters
  get _actionButton() {
    return p.findOne(xl, this._element);
  }
  get _buttonListElements() {
    return p.find(Pl, this._element);
  }
  get _buttonList() {
    return p.findOne(Rl, this._element);
  }
  get _isTouchDevice() {
    return "ontouchstart" in document.documentElement;
  }
  // Public
  show() {
    c.hasClass(this._element, Be) && (u.off(this._buttonList, zt), u.trigger(this._element, Ll), this._bindListOpenTransitionEnd(), c.addStyle(this._element, { height: `${this._fullContainerHeight}px` }), this._toggleVisibility(!0));
  }
  hide() {
    c.hasClass(this._element, Be) && (u.off(this._buttonList, zt), u.trigger(this._element, $l), this._bindListHideTransitionEnd(), this._toggleVisibility(!1));
  }
  dispose() {
    c.hasClass(this._element, Be) && (u.off(this._actionButton, fn), this._actionButton.removeEventListener(_n, this._fn.mouseenter), this._element.removeEventListener(mn, this._fn.mouseleave)), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _init() {
    c.hasClass(this._element, Be) && (this._saveInitialHeights(), this._setInitialStyles(), this._bindInitialEvents());
  }
  _bindMouseEnter() {
    this._actionButton.addEventListener(
      _n,
      // prettier-ignore
      this._fn.mouseenter = () => {
        this._isTouchDevice || this.show();
      }
      // prettier-ignore
    );
  }
  _bindMouseLeave() {
    this._element.addEventListener(
      mn,
      // prettier-ignore
      this._fn.mouseleave = () => {
        this.hide();
      }
      // prettier-ignore
    );
  }
  _bindClick() {
    u.on(this._actionButton, fn, () => {
      c.hasClass(this._element, gn) ? this.hide() : this.show();
    });
  }
  _bindListHideTransitionEnd() {
    u.on(this._buttonList, zt, (t) => {
      t.propertyName === "transform" && (u.off(this._buttonList, zt), this._element.style.height = `${this._initialContainerHeight}px`, u.trigger(this._element, Ml));
    });
  }
  _bindListOpenTransitionEnd() {
    u.on(this._buttonList, zt, (t) => {
      t.propertyName === "transform" && (u.off(this._buttonList, zt), u.trigger(this._element, kl));
    });
  }
  _toggleVisibility(t) {
    const e = t ? "addClass" : "removeClass", s = t ? "translate(0)" : `translateY(${this._fullContainerHeight}px)`;
    c.addStyle(this._buttonList, { transform: s }), this._buttonListElements && this._buttonListElements.forEach((n) => c[e](n, Il)), c[e](this._element, gn);
  }
  _getHeight(t) {
    const e = window.getComputedStyle(t);
    return parseFloat(e.getPropertyValue("height"));
  }
  _saveInitialHeights() {
    this._initialContainerHeight = this._getHeight(this._element), this._initialListHeight = this._getHeight(this._buttonList), this._fullContainerHeight = this._initialContainerHeight + this._initialListHeight;
  }
  _bindInitialEvents() {
    this._bindClick(), this._bindMouseEnter(), this._bindMouseLeave();
  }
  _setInitialStyles() {
    this._buttonList.style.marginBottom = `${this._initialContainerHeight}px`, this._buttonList.style.transform = `translateY(${this._fullContainerHeight}px)`, this._element.style.height = `${this._initialContainerHeight}px`;
  }
}
const Ki = (i) => {
  let t = i.getAttribute("data-mdb-target");
  if (!t || t === "#") {
    let e = i.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? vr(e.trim()) : null;
  }
  return t;
}, k = {
  find(i, t = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(t, i));
  },
  findOne(i, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, i);
  },
  children(i, t) {
    return [].concat(...i.children).filter((e) => e.matches(t));
  },
  parents(i, t) {
    const e = [];
    let s = i.parentNode.closest(t);
    for (; s; )
      e.push(s), s = s.parentNode.closest(t);
    return e;
  },
  prev(i, t) {
    let e = i.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(i, t) {
    let e = i.nextElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(i) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(",");
    return this.find(t, i).filter((e) => !oe(e) && yi(e));
  },
  getSelectorFromElement(i) {
    const t = Ki(i);
    return t && k.findOne(t) ? t : null;
  },
  getElementFromSelector(i) {
    const t = Ki(i);
    return t ? k.findOne(t) : null;
  },
  getMultipleElementsFromSelector(i) {
    const t = Ki(i);
    return t ? k.find(t) : [];
  }
}, Ir = "backdrop", Vl = "fade", bn = "show", En = `mousedown.bs.${Ir}`, Hl = {
  className: "modal-backdrop",
  clickCallback: null,
  isAnimated: !1,
  isVisible: !0,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: "body"
  // give the choice to place backdrop under different elements
}, Bl = {
  className: "string",
  clickCallback: "(function|null)",
  isAnimated: "boolean",
  isVisible: "boolean",
  rootElement: "(element|string)"
};
class xr extends Me {
  constructor(t) {
    super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
  }
  // Getters
  static get Default() {
    return Hl;
  }
  static get DefaultType() {
    return Bl;
  }
  static get NAME() {
    return Ir;
  }
  // Public
  show(t) {
    if (!this._config.isVisible) {
      J(t);
      return;
    }
    this._append();
    const e = this._getElement();
    this._config.isAnimated && $e(e), e.classList.add(bn), this._emulateAnimation(() => {
      J(t);
    });
  }
  hide(t) {
    if (!this._config.isVisible) {
      J(t);
      return;
    }
    this._getElement().classList.remove(bn), this._emulateAnimation(() => {
      this.dispose(), J(t);
    });
  }
  dispose() {
    this._isAppended && (T.off(this._element, En), this._element.remove(), this._isAppended = !1);
  }
  // Private
  _getElement() {
    if (!this._element) {
      const t = document.createElement("div");
      t.className = this._config.className, this._config.isAnimated && t.classList.add(Vl), this._element = t;
    }
    return this._element;
  }
  _configAfterMerge(t) {
    return t.rootElement = $t(t.rootElement), t;
  }
  _append() {
    if (this._isAppended)
      return;
    const t = this._getElement();
    this._config.rootElement.append(t), T.on(t, En, () => {
      J(this._config.clickCallback);
    }), this._isAppended = !0;
  }
  _emulateAnimation(t) {
    Ar(t, this._getElement(), this._config.isAnimated);
  }
}
const Wt = (i, t = "hide") => {
  const e = `click.dismiss${i.EVENT_KEY}`, s = i.NAME;
  T.on(document, e, `[data-mdb-dismiss="${s}"]`, function(n) {
    if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), oe(this))
      return;
    const o = k.getElementFromSelector(this) || this.closest(`.${s}`);
    i.getOrCreateInstance(o)[t]();
  });
}, Fl = "focustrap", Wl = "bs.focustrap", vi = `.${Wl}`, Yl = `focusin${vi}`, jl = `keydown.tab${vi}`, Kl = "Tab", Ul = "forward", vn = "backward", zl = {
  autofocus: !0,
  trapElement: null
  // The element to trap focus inside of
}, Gl = {
  autofocus: "boolean",
  trapElement: "element"
};
let Pr = class extends Me {
  constructor(t) {
    super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;
  }
  // Getters
  static get Default() {
    return zl;
  }
  static get DefaultType() {
    return Gl;
  }
  static get NAME() {
    return Fl;
  }
  // Public
  activate() {
    this._isActive || (this._config.autofocus && this._config.trapElement.focus(), T.off(document, vi), T.on(document, Yl, (t) => this._handleFocusin(t)), T.on(document, jl, (t) => this._handleKeydown(t)), this._isActive = !0);
  }
  deactivate() {
    this._isActive && (this._isActive = !1, T.off(document, vi));
  }
  // Private
  _handleFocusin(t) {
    const { trapElement: e } = this._config;
    if (t.target === document || t.target === e || e.contains(t.target))
      return;
    const s = k.focusableChildren(e);
    s.length === 0 ? e.focus() : this._lastTabNavDirection === vn ? s[s.length - 1].focus() : s[0].focus();
  }
  _handleKeydown(t) {
    t.key === Kl && (this._lastTabNavDirection = t.shiftKey ? vn : Ul);
  }
};
const Tn = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Cn = ".sticky-top", Fe = "padding-right", An = "margin-right";
class Ne {
  constructor() {
    this._element = document.body;
  }
  // Public
  getWidth() {
    const t = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t);
  }
  hide() {
    const t = this.getWidth();
    this._disableOverFlow(), this._setElementAttributes(
      this._element,
      Fe,
      (e) => e + t
    ), this._setElementAttributes(
      Tn,
      Fe,
      (e) => e + t
    ), this._setElementAttributes(
      Cn,
      An,
      (e) => e - t
    );
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Fe), this._resetElementAttributes(Tn, Fe), this._resetElementAttributes(Cn, An);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
  // Private
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
  }
  _setElementAttributes(t, e, s) {
    const n = this.getWidth(), o = (r) => {
      if (r !== this._element && window.innerWidth > r.clientWidth + n)
        return;
      this._saveInitialAttribute(r, e);
      const a = window.getComputedStyle(r).getPropertyValue(e);
      r.style.setProperty(e, `${s(Number.parseFloat(a))}px`);
    };
    this._applyManipulationCallback(t, o);
  }
  _saveInitialAttribute(t, e) {
    const s = t.style.getPropertyValue(e);
    s && Nt.setDataAttribute(t, e, s);
  }
  _resetElementAttributes(t, e) {
    const s = (n) => {
      const o = Nt.getDataAttribute(n, e);
      if (o === null) {
        n.style.removeProperty(e);
        return;
      }
      Nt.removeDataAttribute(n, e), n.style.setProperty(e, o);
    };
    this._applyManipulationCallback(t, s);
  }
  _applyManipulationCallback(t, e) {
    if (Tt(t)) {
      e(t);
      return;
    }
    for (const s of k.find(t, this._element))
      e(s);
  }
}
const ql = "offcanvas", Xl = "bs.offcanvas", he = `.${Xl}`, Ql = "Escape", yn = "show", On = "showing", Sn = "hiding", Zl = "offcanvas-backdrop", Jl = `show${he}`, tc = `shown${he}`, ec = `hide${he}`, wn = `hidePrevented${he}`, ic = `hidden${he}`, sc = `keydown.dismiss${he}`, nc = {
  backdrop: !0,
  keyboard: !0,
  scroll: !1
}, oc = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  scroll: "boolean"
};
class Rr extends ht {
  constructor(t, e) {
    super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
  }
  // Getters
  static get Default() {
    return nc;
  }
  static get DefaultType() {
    return oc;
  }
  static get NAME() {
    return ql;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    if (this._isShown || T.trigger(this._element, Jl, { relatedTarget: t }).defaultPrevented)
      return;
    this._isShown = !0, this._backdrop.show(), this._config.scroll || new Ne().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(On);
    const s = () => {
      (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(yn), this._element.classList.remove(On), T.trigger(this._element, tc, { relatedTarget: t });
    };
    this._queueCallback(s, this._element, !0);
  }
  hide() {
    if (!this._isShown || T.trigger(this._element, ec).defaultPrevented)
      return;
    this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Sn), this._backdrop.hide();
    const e = () => {
      this._element.classList.remove(yn, Sn), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new Ne().reset(), T.trigger(this._element, ic);
    };
    this._queueCallback(e, this._element, !0);
  }
  dispose() {
    this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
  }
  // Private
  _initializeBackDrop() {
    const t = () => {
      if (this._config.backdrop === "static") {
        T.trigger(this._element, wn);
        return;
      }
      this.hide();
    }, e = !!this._config.backdrop;
    return new xr({
      className: Zl,
      isVisible: e,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      clickCallback: e ? t : null
    });
  }
  _initializeFocusTrap() {
    return new Pr({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    T.on(this._element, sc, (t) => {
      if (t.key === Ql) {
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        T.trigger(this._element, wn);
      }
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Rr.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const rc = "swipe", ue = ".bs.swipe", ac = `touchstart${ue}`, lc = `touchmove${ue}`, cc = `touchend${ue}`, dc = `pointerdown${ue}`, hc = `pointerup${ue}`, uc = "touch", pc = "pen", fc = "pointer-event", _c = 40, mc = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
}, gc = {
  endCallback: "(function|null)",
  leftCallback: "(function|null)",
  rightCallback: "(function|null)"
};
class Ti extends Me {
  constructor(t, e) {
    super(), this._element = t, !(!t || !Ti.isSupported()) && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = !!window.PointerEvent, this._initEvents());
  }
  // Getters
  static get Default() {
    return mc;
  }
  static get DefaultType() {
    return gc;
  }
  static get NAME() {
    return rc;
  }
  // Public
  dispose() {
    T.off(this._element, ue);
  }
  // Private
  _start(t) {
    if (!this._supportPointerEvents) {
      this._deltaX = t.touches[0].clientX;
      return;
    }
    this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX);
  }
  _end(t) {
    this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), J(this._config.endCallback);
  }
  _move(t) {
    this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const t = Math.abs(this._deltaX);
    if (t <= _c)
      return;
    const e = t / this._deltaX;
    this._deltaX = 0, e && J(e > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    this._supportPointerEvents ? (T.on(this._element, dc, (t) => this._start(t)), T.on(this._element, hc, (t) => this._end(t)), this._element.classList.add(fc)) : (T.on(this._element, ac, (t) => this._start(t)), T.on(this._element, lc, (t) => this._move(t)), T.on(this._element, cc, (t) => this._end(t)));
  }
  _eventIsPointerPenTouch(t) {
    return this._supportPointerEvents && (t.pointerType === pc || t.pointerType === uc);
  }
  // Static
  static isSupported() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
}
const bc = "carousel", Ec = "bs.carousel", pe = `.${Ec}`, vc = "ArrowLeft", Tc = "ArrowRight", Cc = 500, Ee = "next", Gt = "prev", Zt = "left", ai = "right", Ac = `slide${pe}`, Ui = `slid${pe}`, yc = `keydown${pe}`, Oc = `mouseenter${pe}`, Sc = `mouseleave${pe}`, wc = `dragstart${pe}`, Nc = "carousel", We = "active", Dc = "slide", $c = "carousel-item-end", Mc = "carousel-item-start", Lc = "carousel-item-next", kc = "carousel-item-prev", Vr = ".active", Hr = ".carousel-item", Ic = Vr + Hr, xc = ".carousel-item img", Pc = ".carousel-indicators", Rc = {
  [vc]: ai,
  [Tc]: Zt
}, Vc = {
  interval: 5e3,
  keyboard: !0,
  pause: "hover",
  ride: !1,
  touch: !0,
  wrap: !0
}, Hc = {
  interval: "(number|boolean)",
  // TODO:v6 remove boolean support
  keyboard: "boolean",
  pause: "(string|boolean)",
  ride: "(boolean|string)",
  touch: "boolean",
  wrap: "boolean"
};
let Bc = class Br extends ht {
  constructor(t, e) {
    super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = k.findOne(Pc, this._element), this._addEventListeners(), this._config.ride === Nc && this.cycle();
  }
  // Getters
  static get Default() {
    return Vc;
  }
  static get DefaultType() {
    return Hc;
  }
  static get NAME() {
    return bc;
  }
  // Public
  next() {
    this._slide(Ee);
  }
  nextWhenVisible() {
    !document.hidden && yi(this._element) && this.next();
  }
  prev() {
    this._slide(Gt);
  }
  pause() {
    this._isSliding && Tr(this._element), this._clearInterval();
  }
  cycle() {
    this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (this._config.ride) {
      if (this._isSliding) {
        T.one(this._element, Ui, () => this.cycle());
        return;
      }
      this.cycle();
    }
  }
  to(t) {
    const e = this._getItems();
    if (t > e.length - 1 || t < 0)
      return;
    if (this._isSliding) {
      T.one(this._element, Ui, () => this.to(t));
      return;
    }
    const s = this._getItemIndex(this._getActive());
    if (s === t)
      return;
    const n = t > s ? Ee : Gt;
    this._slide(n, e[t]);
  }
  dispose() {
    this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
  }
  // Private
  _configAfterMerge(t) {
    return t.defaultInterval = t.interval, t;
  }
  _addEventListeners() {
    this._config.keyboard && T.on(this._element, yc, (t) => this._keydown(t)), this._config.pause === "hover" && (T.on(this._element, Oc, () => this.pause()), T.on(this._element, Sc, () => this._maybeEnableCycle())), this._config.touch && Ti.isSupported() && this._addTouchEventListeners();
  }
  _addTouchEventListeners() {
    for (const s of k.find(xc, this._element))
      T.on(s, wc, (n) => n.preventDefault());
    const e = {
      leftCallback: () => this._slide(this._directionToOrder(Zt)),
      rightCallback: () => this._slide(this._directionToOrder(ai)),
      endCallback: () => {
        this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(
          () => this._maybeEnableCycle(),
          Cc + this._config.interval
        ));
      }
    };
    this._swipeHelper = new Ti(this._element, e);
  }
  _keydown(t) {
    if (/input|textarea/i.test(t.target.tagName))
      return;
    const e = Rc[t.key];
    e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
  }
  _getItemIndex(t) {
    return this._getItems().indexOf(t);
  }
  _setActiveIndicatorElement(t) {
    if (!this._indicatorsElement)
      return;
    const e = k.findOne(Vr, this._indicatorsElement);
    e.classList.remove(We), e.removeAttribute("aria-current");
    const s = k.findOne(
      `[data-mdb-slide-to="${t}"]`,
      this._indicatorsElement
    );
    s && (s.classList.add(We), s.setAttribute("aria-current", "true"));
  }
  _updateInterval() {
    const t = this._activeElement || this._getActive();
    if (!t)
      return;
    const e = Number.parseInt(t.getAttribute("data-mdb-interval"), 10);
    this._config.interval = e || this._config.defaultInterval;
  }
  _slide(t, e = null) {
    if (this._isSliding)
      return;
    const s = this._getActive(), n = t === Ee, o = e || Is(this._getItems(), s, n, this._config.wrap);
    if (o === s)
      return;
    const r = this._getItemIndex(o), a = (_) => T.trigger(this._element, _, {
      relatedTarget: o,
      direction: this._orderToDirection(t),
      from: this._getItemIndex(s),
      to: r
    });
    if (a(Ac).defaultPrevented || !s || !o)
      return;
    const d = !!this._interval;
    this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(r), this._activeElement = o;
    const h = n ? Mc : $c, f = n ? Lc : kc;
    o.classList.add(f), $e(o), s.classList.add(h), o.classList.add(h);
    const m = () => {
      o.classList.remove(h, f), o.classList.add(We), s.classList.remove(We, f, h), this._isSliding = !1, a(Ui);
    };
    this._queueCallback(m, s, this._isAnimated()), d && this.cycle();
  }
  _isAnimated() {
    return this._element.classList.contains(Dc);
  }
  _getActive() {
    return k.findOne(Ic, this._element);
  }
  _getItems() {
    return k.find(Hr, this._element);
  }
  _clearInterval() {
    this._interval && (clearInterval(this._interval), this._interval = null);
  }
  _directionToOrder(t) {
    return at() ? t === Zt ? Gt : Ee : t === Zt ? Ee : Gt;
  }
  _orderToDirection(t) {
    return at() ? t === Gt ? Zt : ai : t === Gt ? ai : Zt;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Br.getOrCreateInstance(this, t);
      if (typeof t == "number") {
        e.to(t);
        return;
      }
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const Nn = "carousel", Fc = "slide.bs.carousel", Wc = "slid.bs.carousel", Yc = [
  { name: "slide", parametersToCopy: ["relatedTarget", "direction", "from", "to"] },
  { name: "slid", parametersToCopy: ["relatedTarget", "direction", "from", "to"] }
];
class km extends Bc {
  constructor(t, e) {
    super(t, e), this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._element, Fc), u.off(this._element, Wc), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Nn;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    u.extend(this._element, Yc, Nn);
  }
}
var z = "top", et = "bottom", it = "right", G = "left", Oi = "auto", fe = [z, et, it, G], Bt = "start", re = "end", Fr = "clippingParents", Ps = "viewport", Jt = "popper", Wr = "reference", As = /* @__PURE__ */ fe.reduce(function(i, t) {
  return i.concat([t + "-" + Bt, t + "-" + re]);
}, []), Rs = /* @__PURE__ */ [].concat(fe, [Oi]).reduce(function(i, t) {
  return i.concat([t, t + "-" + Bt, t + "-" + re]);
}, []), Yr = "beforeRead", jr = "read", Kr = "afterRead", Ur = "beforeMain", zr = "main", Gr = "afterMain", qr = "beforeWrite", Xr = "write", Qr = "afterWrite", Zr = [Yr, jr, Kr, Ur, zr, Gr, qr, Xr, Qr];
function mt(i) {
  return i ? (i.nodeName || "").toLowerCase() : null;
}
function st(i) {
  if (i == null)
    return window;
  if (i.toString() !== "[object Window]") {
    var t = i.ownerDocument;
    return t && t.defaultView || window;
  }
  return i;
}
function Ft(i) {
  var t = st(i).Element;
  return i instanceof t || i instanceof Element;
}
function rt(i) {
  var t = st(i).HTMLElement;
  return i instanceof t || i instanceof HTMLElement;
}
function Vs(i) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = st(i).ShadowRoot;
  return i instanceof t || i instanceof ShadowRoot;
}
function jc(i) {
  var t = i.state;
  Object.keys(t.elements).forEach(function(e) {
    var s = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
    !rt(o) || !mt(o) || (Object.assign(o.style, s), Object.keys(n).forEach(function(r) {
      var a = n[r];
      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? "" : a);
    }));
  });
}
function Kc(i) {
  var t = i.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(s) {
      var n = t.elements[s], o = t.attributes[s] || {}, r = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : e[s]), a = r.reduce(function(l, d) {
        return l[d] = "", l;
      }, {});
      !rt(n) || !mt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const Hs = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: jc,
  effect: Kc,
  requires: ["computeStyles"]
};
function ft(i) {
  return i.split("-")[0];
}
var Ht = Math.max, Ci = Math.min, ae = Math.round;
function ys() {
  var i = navigator.userAgentData;
  return i != null && i.brands && Array.isArray(i.brands) ? i.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function Jr() {
  return !/^((?!chrome|android).)*safari/i.test(ys());
}
function le(i, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var s = i.getBoundingClientRect(), n = 1, o = 1;
  t && rt(i) && (n = i.offsetWidth > 0 && ae(s.width) / i.offsetWidth || 1, o = i.offsetHeight > 0 && ae(s.height) / i.offsetHeight || 1);
  var r = Ft(i) ? st(i) : window, a = r.visualViewport, l = !Jr() && e, d = (s.left + (l && a ? a.offsetLeft : 0)) / n, h = (s.top + (l && a ? a.offsetTop : 0)) / o, f = s.width / n, m = s.height / o;
  return {
    width: f,
    height: m,
    top: h,
    right: d + f,
    bottom: h + m,
    left: d,
    x: d,
    y: h
  };
}
function Bs(i) {
  var t = le(i), e = i.offsetWidth, s = i.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), {
    x: i.offsetLeft,
    y: i.offsetTop,
    width: e,
    height: s
  };
}
function ta(i, t) {
  var e = t.getRootNode && t.getRootNode();
  if (i.contains(t))
    return !0;
  if (e && Vs(e)) {
    var s = t;
    do {
      if (s && i.isSameNode(s))
        return !0;
      s = s.parentNode || s.host;
    } while (s);
  }
  return !1;
}
function Ct(i) {
  return st(i).getComputedStyle(i);
}
function Uc(i) {
  return ["table", "td", "th"].indexOf(mt(i)) >= 0;
}
function Mt(i) {
  return ((Ft(i) ? i.ownerDocument : (
    // $FlowFixMe[prop-missing]
    i.document
  )) || window.document).documentElement;
}
function Si(i) {
  return mt(i) === "html" ? i : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    i.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    i.parentNode || // DOM Element detected
    (Vs(i) ? i.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Mt(i)
  );
}
function Dn(i) {
  return !rt(i) || // https://github.com/popperjs/popper-core/issues/837
  Ct(i).position === "fixed" ? null : i.offsetParent;
}
function zc(i) {
  var t = /firefox/i.test(ys()), e = /Trident/i.test(ys());
  if (e && rt(i)) {
    var s = Ct(i);
    if (s.position === "fixed")
      return null;
  }
  var n = Si(i);
  for (Vs(n) && (n = n.host); rt(n) && ["html", "body"].indexOf(mt(n)) < 0; ) {
    var o = Ct(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function ke(i) {
  for (var t = st(i), e = Dn(i); e && Uc(e) && Ct(e).position === "static"; )
    e = Dn(e);
  return e && (mt(e) === "html" || mt(e) === "body" && Ct(e).position === "static") ? t : e || zc(i) || t;
}
function Fs(i) {
  return ["top", "bottom"].indexOf(i) >= 0 ? "x" : "y";
}
function Ce(i, t, e) {
  return Ht(i, Ci(t, e));
}
function Gc(i, t, e) {
  var s = Ce(i, t, e);
  return s > e ? e : s;
}
function ea() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function ia(i) {
  return Object.assign({}, ea(), i);
}
function sa(i, t) {
  return t.reduce(function(e, s) {
    return e[s] = i, e;
  }, {});
}
var qc = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, ia(typeof t != "number" ? t : sa(t, fe));
};
function Xc(i) {
  var t, e = i.state, s = i.name, n = i.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = ft(e.placement), l = Fs(a), d = [G, it].indexOf(a) >= 0, h = d ? "height" : "width";
  if (!(!o || !r)) {
    var f = qc(n.padding, e), m = Bs(o), _ = l === "y" ? z : G, g = l === "y" ? et : it, b = e.rects.reference[h] + e.rects.reference[l] - r[l] - e.rects.popper[h], y = r[l] - e.rects.reference[l], O = ke(o), N = O ? l === "y" ? O.clientHeight || 0 : O.clientWidth || 0 : 0, E = b / 2 - y / 2, v = f[_], C = N - m[h] - f[g], A = N / 2 - m[h] / 2 + E, w = Ce(v, A, C), $ = l;
    e.modifiersData[s] = (t = {}, t[$] = w, t.centerOffset = w - A, t);
  }
}
function Qc(i) {
  var t = i.state, e = i.options, s = e.element, n = s === void 0 ? "[data-popper-arrow]" : s;
  n != null && (typeof n == "string" && (n = t.elements.popper.querySelector(n), !n) || ta(t.elements.popper, n) && (t.elements.arrow = n));
}
const na = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Xc,
  effect: Qc,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function ce(i) {
  return i.split("-")[1];
}
var Zc = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Jc(i, t) {
  var e = i.x, s = i.y, n = t.devicePixelRatio || 1;
  return {
    x: ae(e * n) / n || 0,
    y: ae(s * n) / n || 0
  };
}
function $n(i) {
  var t, e = i.popper, s = i.popperRect, n = i.placement, o = i.variation, r = i.offsets, a = i.position, l = i.gpuAcceleration, d = i.adaptive, h = i.roundOffsets, f = i.isFixed, m = r.x, _ = m === void 0 ? 0 : m, g = r.y, b = g === void 0 ? 0 : g, y = typeof h == "function" ? h({
    x: _,
    y: b
  }) : {
    x: _,
    y: b
  };
  _ = y.x, b = y.y;
  var O = r.hasOwnProperty("x"), N = r.hasOwnProperty("y"), E = G, v = z, C = window;
  if (d) {
    var A = ke(e), w = "clientHeight", $ = "clientWidth";
    if (A === st(e) && (A = Mt(e), Ct(A).position !== "static" && a === "absolute" && (w = "scrollHeight", $ = "scrollWidth")), A = A, n === z || (n === G || n === it) && o === re) {
      v = et;
      var S = f && A === C && C.visualViewport ? C.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        A[w]
      );
      b -= S - s.height, b *= l ? 1 : -1;
    }
    if (n === G || (n === z || n === et) && o === re) {
      E = it;
      var D = f && A === C && C.visualViewport ? C.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        A[$]
      );
      _ -= D - s.width, _ *= l ? 1 : -1;
    }
  }
  var M = Object.assign({
    position: a
  }, d && Zc), L = h === !0 ? Jc({
    x: _,
    y: b
  }, st(e)) : {
    x: _,
    y: b
  };
  if (_ = L.x, b = L.y, l) {
    var I;
    return Object.assign({}, M, (I = {}, I[v] = N ? "0" : "", I[E] = O ? "0" : "", I.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + _ + "px, " + b + "px)" : "translate3d(" + _ + "px, " + b + "px, 0)", I));
  }
  return Object.assign({}, M, (t = {}, t[v] = N ? b + "px" : "", t[E] = O ? _ + "px" : "", t.transform = "", t));
}
function td(i) {
  var t = i.state, e = i.options, s = e.gpuAcceleration, n = s === void 0 ? !0 : s, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a, d = {
    placement: ft(t.placement),
    variation: ce(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, $n(Object.assign({}, d, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, $n(Object.assign({}, d, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const Ws = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: td,
  data: {}
};
var Ye = {
  passive: !0
};
function ed(i) {
  var t = i.state, e = i.instance, s = i.options, n = s.scroll, o = n === void 0 ? !0 : n, r = s.resize, a = r === void 0 ? !0 : r, l = st(t.elements.popper), d = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && d.forEach(function(h) {
    h.addEventListener("scroll", e.update, Ye);
  }), a && l.addEventListener("resize", e.update, Ye), function() {
    o && d.forEach(function(h) {
      h.removeEventListener("scroll", e.update, Ye);
    }), a && l.removeEventListener("resize", e.update, Ye);
  };
}
const Ys = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: ed,
  data: {}
};
var id = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function li(i) {
  return i.replace(/left|right|bottom|top/g, function(t) {
    return id[t];
  });
}
var sd = {
  start: "end",
  end: "start"
};
function Mn(i) {
  return i.replace(/start|end/g, function(t) {
    return sd[t];
  });
}
function js(i) {
  var t = st(i), e = t.pageXOffset, s = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: s
  };
}
function Ks(i) {
  return le(Mt(i)).left + js(i).scrollLeft;
}
function nd(i, t) {
  var e = st(i), s = Mt(i), n = e.visualViewport, o = s.clientWidth, r = s.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, r = n.height;
    var d = Jr();
    (d || !d && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: a + Ks(i),
    y: l
  };
}
function od(i) {
  var t, e = Mt(i), s = js(i), n = (t = i.ownerDocument) == null ? void 0 : t.body, o = Ht(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = Ht(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -s.scrollLeft + Ks(i), l = -s.scrollTop;
  return Ct(n || e).direction === "rtl" && (a += Ht(e.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
function Us(i) {
  var t = Ct(i), e = t.overflow, s = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + s);
}
function oa(i) {
  return ["html", "body", "#document"].indexOf(mt(i)) >= 0 ? i.ownerDocument.body : rt(i) && Us(i) ? i : oa(Si(i));
}
function Ae(i, t) {
  var e;
  t === void 0 && (t = []);
  var s = oa(i), n = s === ((e = i.ownerDocument) == null ? void 0 : e.body), o = st(s), r = n ? [o].concat(o.visualViewport || [], Us(s) ? s : []) : s, a = t.concat(r);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Ae(Si(r)))
  );
}
function Os(i) {
  return Object.assign({}, i, {
    left: i.x,
    top: i.y,
    right: i.x + i.width,
    bottom: i.y + i.height
  });
}
function rd(i, t) {
  var e = le(i, !1, t === "fixed");
  return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e;
}
function Ln(i, t, e) {
  return t === Ps ? Os(nd(i, e)) : Ft(t) ? rd(t, e) : Os(od(Mt(i)));
}
function ad(i) {
  var t = Ae(Si(i)), e = ["absolute", "fixed"].indexOf(Ct(i).position) >= 0, s = e && rt(i) ? ke(i) : i;
  return Ft(s) ? t.filter(function(n) {
    return Ft(n) && ta(n, s) && mt(n) !== "body";
  }) : [];
}
function ld(i, t, e, s) {
  var n = t === "clippingParents" ? ad(i) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, d) {
    var h = Ln(i, d, s);
    return l.top = Ht(h.top, l.top), l.right = Ci(h.right, l.right), l.bottom = Ci(h.bottom, l.bottom), l.left = Ht(h.left, l.left), l;
  }, Ln(i, r, s));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function ra(i) {
  var t = i.reference, e = i.element, s = i.placement, n = s ? ft(s) : null, o = s ? ce(s) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
  switch (n) {
    case z:
      l = {
        x: r,
        y: t.y - e.height
      };
      break;
    case et:
      l = {
        x: r,
        y: t.y + t.height
      };
      break;
    case it:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case G:
      l = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var d = n ? Fs(n) : null;
  if (d != null) {
    var h = d === "y" ? "height" : "width";
    switch (o) {
      case Bt:
        l[d] = l[d] - (t[h] / 2 - e[h] / 2);
        break;
      case re:
        l[d] = l[d] + (t[h] / 2 - e[h] / 2);
        break;
    }
  }
  return l;
}
function de(i, t) {
  t === void 0 && (t = {});
  var e = t, s = e.placement, n = s === void 0 ? i.placement : s, o = e.strategy, r = o === void 0 ? i.strategy : o, a = e.boundary, l = a === void 0 ? Fr : a, d = e.rootBoundary, h = d === void 0 ? Ps : d, f = e.elementContext, m = f === void 0 ? Jt : f, _ = e.altBoundary, g = _ === void 0 ? !1 : _, b = e.padding, y = b === void 0 ? 0 : b, O = ia(typeof y != "number" ? y : sa(y, fe)), N = m === Jt ? Wr : Jt, E = i.rects.popper, v = i.elements[g ? N : m], C = ld(Ft(v) ? v : v.contextElement || Mt(i.elements.popper), l, h, r), A = le(i.elements.reference), w = ra({
    reference: A,
    element: E,
    strategy: "absolute",
    placement: n
  }), $ = Os(Object.assign({}, E, w)), S = m === Jt ? $ : A, D = {
    top: C.top - S.top + O.top,
    bottom: S.bottom - C.bottom + O.bottom,
    left: C.left - S.left + O.left,
    right: S.right - C.right + O.right
  }, M = i.modifiersData.offset;
  if (m === Jt && M) {
    var L = M[n];
    Object.keys(D).forEach(function(I) {
      var H = [it, et].indexOf(I) >= 0 ? 1 : -1, q = [z, et].indexOf(I) >= 0 ? "y" : "x";
      D[I] += L[q] * H;
    });
  }
  return D;
}
function cd(i, t) {
  t === void 0 && (t = {});
  var e = t, s = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, d = l === void 0 ? Rs : l, h = ce(s), f = h ? a ? As : As.filter(function(g) {
    return ce(g) === h;
  }) : fe, m = f.filter(function(g) {
    return d.indexOf(g) >= 0;
  });
  m.length === 0 && (m = f);
  var _ = m.reduce(function(g, b) {
    return g[b] = de(i, {
      placement: b,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[ft(b)], g;
  }, {});
  return Object.keys(_).sort(function(g, b) {
    return _[g] - _[b];
  });
}
function dd(i) {
  if (ft(i) === Oi)
    return [];
  var t = li(i);
  return [Mn(i), t, Mn(t)];
}
function hd(i) {
  var t = i.state, e = i.options, s = i.name;
  if (!t.modifiersData[s]._skip) {
    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, d = e.padding, h = e.boundary, f = e.rootBoundary, m = e.altBoundary, _ = e.flipVariations, g = _ === void 0 ? !0 : _, b = e.allowedAutoPlacements, y = t.options.placement, O = ft(y), N = O === y, E = l || (N || !g ? [li(y)] : dd(y)), v = [y].concat(E).reduce(function(jt, At) {
      return jt.concat(ft(At) === Oi ? cd(t, {
        placement: At,
        boundary: h,
        rootBoundary: f,
        padding: d,
        flipVariations: g,
        allowedAutoPlacements: b
      }) : At);
    }, []), C = t.rects.reference, A = t.rects.popper, w = /* @__PURE__ */ new Map(), $ = !0, S = v[0], D = 0; D < v.length; D++) {
      var M = v[D], L = ft(M), I = ce(M) === Bt, H = [z, et].indexOf(L) >= 0, q = H ? "width" : "height", W = de(t, {
        placement: M,
        boundary: h,
        rootBoundary: f,
        altBoundary: m,
        padding: d
      }), tt = H ? I ? it : G : I ? et : z;
      C[q] > A[q] && (tt = li(tt));
      var xe = li(tt), kt = [];
      if (o && kt.push(W[L] <= 0), a && kt.push(W[tt] <= 0, W[xe] <= 0), kt.every(function(jt) {
        return jt;
      })) {
        S = M, $ = !1;
        break;
      }
      w.set(M, kt);
    }
    if ($)
      for (var Pe = g ? 3 : 1, Ii = function(At) {
        var be = v.find(function(Ve) {
          var It = w.get(Ve);
          if (It)
            return It.slice(0, At).every(function(xi) {
              return xi;
            });
        });
        if (be)
          return S = be, "break";
      }, ge = Pe; ge > 0; ge--) {
        var Re = Ii(ge);
        if (Re === "break")
          break;
      }
    t.placement !== S && (t.modifiersData[s]._skip = !0, t.placement = S, t.reset = !0);
  }
}
const aa = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: hd,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function kn(i, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: i.top - t.height - e.y,
    right: i.right - t.width + e.x,
    bottom: i.bottom - t.height + e.y,
    left: i.left - t.width - e.x
  };
}
function In(i) {
  return [z, it, et, G].some(function(t) {
    return i[t] >= 0;
  });
}
function ud(i) {
  var t = i.state, e = i.name, s = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = de(t, {
    elementContext: "reference"
  }), a = de(t, {
    altBoundary: !0
  }), l = kn(r, s), d = kn(a, n, o), h = In(l), f = In(d);
  t.modifiersData[e] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: d,
    isReferenceHidden: h,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": h,
    "data-popper-escaped": f
  });
}
const la = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: ud
};
function pd(i, t, e) {
  var s = ft(i), n = [G, z].indexOf(s) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
    placement: i
  })) : e, r = o[0], a = o[1];
  return r = r || 0, a = (a || 0) * n, [G, it].indexOf(s) >= 0 ? {
    x: a,
    y: r
  } : {
    x: r,
    y: a
  };
}
function fd(i) {
  var t = i.state, e = i.options, s = i.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = Rs.reduce(function(h, f) {
    return h[f] = pd(f, t.rects, o), h;
  }, {}), a = r[t.placement], l = a.x, d = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += d), t.modifiersData[s] = r;
}
const ca = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: fd
};
function _d(i) {
  var t = i.state, e = i.name;
  t.modifiersData[e] = ra({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const zs = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: _d,
  data: {}
};
function md(i) {
  return i === "x" ? "y" : "x";
}
function gd(i) {
  var t = i.state, e = i.options, s = i.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, d = e.rootBoundary, h = e.altBoundary, f = e.padding, m = e.tether, _ = m === void 0 ? !0 : m, g = e.tetherOffset, b = g === void 0 ? 0 : g, y = de(t, {
    boundary: l,
    rootBoundary: d,
    padding: f,
    altBoundary: h
  }), O = ft(t.placement), N = ce(t.placement), E = !N, v = Fs(O), C = md(v), A = t.modifiersData.popperOffsets, w = t.rects.reference, $ = t.rects.popper, S = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, D = typeof S == "number" ? {
    mainAxis: S,
    altAxis: S
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, S), M = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, L = {
    x: 0,
    y: 0
  };
  if (A) {
    if (o) {
      var I, H = v === "y" ? z : G, q = v === "y" ? et : it, W = v === "y" ? "height" : "width", tt = A[v], xe = tt + y[H], kt = tt - y[q], Pe = _ ? -$[W] / 2 : 0, Ii = N === Bt ? w[W] : $[W], ge = N === Bt ? -$[W] : -w[W], Re = t.elements.arrow, jt = _ && Re ? Bs(Re) : {
        width: 0,
        height: 0
      }, At = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : ea(), be = At[H], Ve = At[q], It = Ce(0, w[W], jt[W]), xi = E ? w[W] / 2 - Pe - It - be - D.mainAxis : Ii - It - be - D.mainAxis, za = E ? -w[W] / 2 + Pe + It + Ve + D.mainAxis : ge + It + Ve + D.mainAxis, Pi = t.elements.arrow && ke(t.elements.arrow), Ga = Pi ? v === "y" ? Pi.clientTop || 0 : Pi.clientLeft || 0 : 0, Xs = (I = M == null ? void 0 : M[v]) != null ? I : 0, qa = tt + xi - Xs - Ga, Xa = tt + za - Xs, Qs = Ce(_ ? Ci(xe, qa) : xe, tt, _ ? Ht(kt, Xa) : kt);
      A[v] = Qs, L[v] = Qs - tt;
    }
    if (a) {
      var Zs, Qa = v === "x" ? z : G, Za = v === "x" ? et : it, xt = A[C], He = C === "y" ? "height" : "width", Js = xt + y[Qa], tn = xt - y[Za], Ri = [z, G].indexOf(O) !== -1, en = (Zs = M == null ? void 0 : M[C]) != null ? Zs : 0, sn = Ri ? Js : xt - w[He] - $[He] - en + D.altAxis, nn = Ri ? xt + w[He] + $[He] - en - D.altAxis : tn, on = _ && Ri ? Gc(sn, xt, nn) : Ce(_ ? sn : Js, xt, _ ? nn : tn);
      A[C] = on, L[C] = on - xt;
    }
    t.modifiersData[s] = L;
  }
}
const da = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: gd,
  requiresIfExists: ["offset"]
};
function bd(i) {
  return {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  };
}
function Ed(i) {
  return i === st(i) || !rt(i) ? js(i) : bd(i);
}
function vd(i) {
  var t = i.getBoundingClientRect(), e = ae(t.width) / i.offsetWidth || 1, s = ae(t.height) / i.offsetHeight || 1;
  return e !== 1 || s !== 1;
}
function Td(i, t, e) {
  e === void 0 && (e = !1);
  var s = rt(t), n = rt(t) && vd(t), o = Mt(t), r = le(i, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (s || !s && !e) && ((mt(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Us(o)) && (a = Ed(t)), rt(t) ? (l = le(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = Ks(o))), {
    x: r.left + a.scrollLeft - l.x,
    y: r.top + a.scrollTop - l.y,
    width: r.width,
    height: r.height
  };
}
function Cd(i) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), s = [];
  i.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    e.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(a) {
      if (!e.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), s.push(o);
  }
  return i.forEach(function(o) {
    e.has(o.name) || n(o);
  }), s;
}
function Ad(i) {
  var t = Cd(i);
  return Zr.reduce(function(e, s) {
    return e.concat(t.filter(function(n) {
      return n.phase === s;
    }));
  }, []);
}
function yd(i) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(i());
      });
    })), t;
  };
}
function Od(i) {
  var t = i.reduce(function(e, s) {
    var n = e[s.name];
    return e[s.name] = n ? Object.assign({}, n, s, {
      options: Object.assign({}, n.options, s.options),
      data: Object.assign({}, n.data, s.data)
    }) : s, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var xn = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Pn() {
  for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)
    t[e] = arguments[e];
  return !t.some(function(s) {
    return !(s && typeof s.getBoundingClientRect == "function");
  });
}
function wi(i) {
  i === void 0 && (i = {});
  var t = i, e = t.defaultModifiers, s = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? xn : n;
  return function(a, l, d) {
    d === void 0 && (d = o);
    var h = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, xn, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], m = !1, _ = {
      state: h,
      setOptions: function(O) {
        var N = typeof O == "function" ? O(h.options) : O;
        b(), h.options = Object.assign({}, o, h.options, N), h.scrollParents = {
          reference: Ft(a) ? Ae(a) : a.contextElement ? Ae(a.contextElement) : [],
          popper: Ae(l)
        };
        var E = Ad(Od([].concat(s, h.options.modifiers)));
        return h.orderedModifiers = E.filter(function(v) {
          return v.enabled;
        }), g(), _.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!m) {
          var O = h.elements, N = O.reference, E = O.popper;
          if (Pn(N, E)) {
            h.rects = {
              reference: Td(N, ke(E), h.options.strategy === "fixed"),
              popper: Bs(E)
            }, h.reset = !1, h.placement = h.options.placement, h.orderedModifiers.forEach(function(D) {
              return h.modifiersData[D.name] = Object.assign({}, D.data);
            });
            for (var v = 0; v < h.orderedModifiers.length; v++) {
              if (h.reset === !0) {
                h.reset = !1, v = -1;
                continue;
              }
              var C = h.orderedModifiers[v], A = C.fn, w = C.options, $ = w === void 0 ? {} : w, S = C.name;
              typeof A == "function" && (h = A({
                state: h,
                options: $,
                name: S,
                instance: _
              }) || h);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: yd(function() {
        return new Promise(function(y) {
          _.forceUpdate(), y(h);
        });
      }),
      destroy: function() {
        b(), m = !0;
      }
    };
    if (!Pn(a, l))
      return _;
    _.setOptions(d).then(function(y) {
      !m && d.onFirstUpdate && d.onFirstUpdate(y);
    });
    function g() {
      h.orderedModifiers.forEach(function(y) {
        var O = y.name, N = y.options, E = N === void 0 ? {} : N, v = y.effect;
        if (typeof v == "function") {
          var C = v({
            state: h,
            name: O,
            instance: _,
            options: E
          }), A = function() {
          };
          f.push(C || A);
        }
      });
    }
    function b() {
      f.forEach(function(y) {
        return y();
      }), f = [];
    }
    return _;
  };
}
var Sd = /* @__PURE__ */ wi(), wd = [Ys, zs, Ws, Hs], Nd = /* @__PURE__ */ wi({
  defaultModifiers: wd
}), Dd = [Ys, zs, Ws, Hs, ca, aa, da, na, la], _e = /* @__PURE__ */ wi({
  defaultModifiers: Dd
});
const ha = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain: Gr,
  afterRead: Kr,
  afterWrite: Qr,
  applyStyles: Hs,
  arrow: na,
  auto: Oi,
  basePlacements: fe,
  beforeMain: Ur,
  beforeRead: Yr,
  beforeWrite: qr,
  bottom: et,
  clippingParents: Fr,
  computeStyles: Ws,
  createPopper: _e,
  createPopperBase: Sd,
  createPopperLite: Nd,
  detectOverflow: de,
  end: re,
  eventListeners: Ys,
  flip: aa,
  hide: la,
  left: G,
  main: zr,
  modifierPhases: Zr,
  offset: ca,
  placements: Rs,
  popper: Jt,
  popperGenerator: wi,
  popperOffsets: zs,
  preventOverflow: da,
  read: jr,
  reference: Wr,
  right: it,
  start: Bt,
  top: z,
  variationPlacements: As,
  viewport: Ps,
  write: Xr
}, Symbol.toStringTag, { value: "Module" })), $d = /^aria-[\w-]*$/i, ua = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", $d],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, Md = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Ld = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, kd = (i, t) => {
  const e = i.nodeName.toLowerCase();
  return t.includes(e) ? Md.has(e) ? !!Ld.test(i.nodeValue) : !0 : t.filter((s) => s instanceof RegExp).some((s) => s.test(e));
};
function Id(i, t, e) {
  if (!i.length)
    return i;
  if (e && typeof e == "function")
    return e(i);
  const n = new window.DOMParser().parseFromString(i, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
  for (const r of o) {
    const a = r.nodeName.toLowerCase();
    if (!Object.keys(t).includes(a)) {
      r.remove();
      continue;
    }
    const l = [].concat(...r.attributes), d = [].concat(t["*"] || [], t[a] || []);
    for (const h of l)
      kd(h, d) || r.removeAttribute(h.nodeName);
  }
  return n.body.innerHTML;
}
const xd = "TemplateFactory", Pd = {
  allowList: ua,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: "",
  html: !1,
  sanitize: !0,
  sanitizeFn: null,
  template: "<div></div>"
}, Rd = {
  allowList: "object",
  content: "object",
  extraClass: "(string|function)",
  html: "boolean",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  template: "string"
}, Vd = {
  entry: "(string|element|function|null)",
  selector: "(string|element)"
};
class Hd extends Me {
  constructor(t) {
    super(), this._config = this._getConfig(t);
  }
  // Getters
  static get Default() {
    return Pd;
  }
  static get DefaultType() {
    return Rd;
  }
  static get NAME() {
    return xd;
  }
  // Public
  getContent() {
    return Object.values(this._config.content).map((t) => this._resolvePossibleFunction(t)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(t) {
    return this._checkContent(t), this._config.content = { ...this._config.content, ...t }, this;
  }
  toHtml() {
    const t = document.createElement("div");
    t.innerHTML = this._maybeSanitize(this._config.template);
    for (const [n, o] of Object.entries(this._config.content))
      this._setContent(t, o, n);
    const e = t.children[0], s = this._resolvePossibleFunction(this._config.extraClass);
    return s && e.classList.add(...s.split(" ")), e;
  }
  // Private
  _typeCheckConfig(t) {
    super._typeCheckConfig(t), this._checkContent(t.content);
  }
  _checkContent(t) {
    for (const [e, s] of Object.entries(t))
      super._typeCheckConfig({ selector: e, entry: s }, Vd);
  }
  _setContent(t, e, s) {
    const n = k.findOne(s, t);
    if (n) {
      if (e = this._resolvePossibleFunction(e), !e) {
        n.remove();
        return;
      }
      if (Tt(e)) {
        this._putElementInTemplate($t(e), n);
        return;
      }
      if (this._config.html) {
        n.innerHTML = this._maybeSanitize(e);
        return;
      }
      n.textContent = e;
    }
  }
  _maybeSanitize(t) {
    return this._config.sanitize ? Id(t, this._config.allowList, this._config.sanitizeFn) : t;
  }
  _resolvePossibleFunction(t) {
    return J(t, [this]);
  }
  _putElementInTemplate(t, e) {
    if (this._config.html) {
      e.innerHTML = "", e.append(t);
      return;
    }
    e.textContent = t.textContent;
  }
}
const Bd = "tooltip", Fd = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), zi = "fade", Wd = "modal", je = "show", Yd = ".tooltip-inner", Rn = `.${Wd}`, Vn = "hide.bs.modal", ve = "hover", Gi = "focus", jd = "click", Kd = "manual", Ud = "hide", zd = "hidden", Gd = "show", qd = "shown", Xd = "inserted", Qd = "click", Zd = "focusin", Jd = "focusout", th = "mouseenter", eh = "mouseleave", ih = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: at() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: at() ? "right" : "left"
}, sh = {
  allowList: ua,
  animation: !0,
  boundary: "clippingParents",
  container: !1,
  customClass: "",
  delay: 0,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  html: !1,
  offset: [0, 6],
  placement: "top",
  popperConfig: null,
  sanitize: !0,
  sanitizeFn: null,
  selector: !1,
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  title: "",
  trigger: "hover focus"
}, nh = {
  allowList: "object",
  animation: "boolean",
  boundary: "(string|element)",
  container: "(string|element|boolean)",
  customClass: "(string|function)",
  delay: "(number|object)",
  fallbackPlacements: "array",
  html: "boolean",
  offset: "(array|string|function)",
  placement: "(string|function)",
  popperConfig: "(null|object|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  selector: "(string|boolean)",
  template: "string",
  title: "(string|element|function)",
  trigger: "string"
};
let Ni = class pa extends ht {
  constructor(t, e) {
    if (typeof ha > "u")
      throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
    super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
  }
  // Getters
  static get Default() {
    return sh;
  }
  static get DefaultType() {
    return nh;
  }
  static get NAME() {
    return Bd;
  }
  // Public
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (this._isEnabled) {
      if (this._activeTrigger.click = !this._activeTrigger.click, this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
  }
  dispose() {
    clearTimeout(this._timeout), T.off(
      this._element.closest(Rn),
      Vn,
      this._hideModalHandler
    ), this._element.getAttribute("data-mdb-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-mdb-original-title")), this._disposePopper(), super.dispose();
  }
  show() {
    if (this._element.style.display === "none")
      throw new Error("Please use show on visible elements");
    if (!(this._isWithContent() && this._isEnabled))
      return;
    const t = T.trigger(this._element, this.constructor.eventName(Gd)), s = (Cr(this._element) || this._element.ownerDocument.documentElement).contains(
      this._element
    );
    if (t.defaultPrevented || !s)
      return;
    this._disposePopper();
    const n = this._getTipElement();
    this._element.setAttribute("aria-describedby", n.getAttribute("id"));
    const { container: o } = this._config;
    if (this._element.ownerDocument.documentElement.contains(this.tip) || (o.append(n), T.trigger(this._element, this.constructor.eventName(Xd))), this._popper = this._createPopper(n), n.classList.add(je), "ontouchstart" in document.documentElement)
      for (const a of [].concat(...document.body.children))
        T.on(a, "mouseover", bi);
    const r = () => {
      T.trigger(this._element, this.constructor.eventName(qd)), this._isHovered === !1 && this._leave(), this._isHovered = !1;
    };
    this._queueCallback(r, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown() || T.trigger(this._element, this.constructor.eventName(Ud)).defaultPrevented)
      return;
    if (this._getTipElement().classList.remove(je), "ontouchstart" in document.documentElement)
      for (const n of [].concat(...document.body.children))
        T.off(n, "mouseover", bi);
    this._activeTrigger[jd] = !1, this._activeTrigger[Gi] = !1, this._activeTrigger[ve] = !1, this._isHovered = null;
    const s = () => {
      this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), T.trigger(this._element, this.constructor.eventName(zd)));
    };
    this._queueCallback(s, this.tip, this._isAnimated());
  }
  update() {
    this._popper && this._popper.update();
  }
  // Protected
  _isWithContent() {
    return !!this._getTitle();
  }
  _getTipElement() {
    return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
  }
  _createTipElement(t) {
    const e = this._getTemplateFactory(t).toHtml();
    if (!e)
      return null;
    e.classList.remove(zi, je), e.classList.add(`bs-${this.constructor.NAME}-auto`);
    const s = fl(this.constructor.NAME).toString();
    return e.setAttribute("id", s), this._isAnimated() && e.classList.add(zi), e;
  }
  setContent(t) {
    this._newContent = t, this._isShown() && (this._disposePopper(), this.show());
  }
  _getTemplateFactory(t) {
    return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Hd({
      ...this._config,
      // the `content` var has to be after `this._config`
      // to override config.content in case of popover
      content: t,
      extraClass: this._resolvePossibleFunction(this._config.customClass)
    }), this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [Yd]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-mdb-original-title");
  }
  // Private
  _initializeOnDelegatedTarget(t) {
    return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(zi);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(je);
  }
  _createPopper(t) {
    const e = J(this._config.placement, [this, t, this._element]), s = ih[e.toUpperCase()];
    return _e(this._element, t, this._getPopperConfig(s));
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _resolvePossibleFunction(t) {
    return J(t, [this._element]);
  }
  _getPopperConfig(t) {
    const e = {
      placement: t,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "preSetPlacement",
          enabled: !0,
          phase: "beforeMain",
          fn: (s) => {
            this._getTipElement().setAttribute("data-popper-placement", s.state.placement);
          }
        }
      ]
    };
    return {
      ...e,
      ...J(this._config.popperConfig, [e])
    };
  }
  _setListeners() {
    const t = this._config.trigger.split(" ");
    for (const e of t)
      if (e === "click")
        T.on(
          this._element,
          this.constructor.eventName(Qd),
          this._config.selector,
          (s) => {
            this._initializeOnDelegatedTarget(s).toggle();
          }
        );
      else if (e !== Kd) {
        const s = e === ve ? this.constructor.eventName(th) : this.constructor.eventName(Zd), n = e === ve ? this.constructor.eventName(eh) : this.constructor.eventName(Jd);
        T.on(this._element, s, this._config.selector, (o) => {
          const r = this._initializeOnDelegatedTarget(o);
          r._activeTrigger[o.type === "focusin" ? Gi : ve] = !0, r._enter();
        }), T.on(this._element, n, this._config.selector, (o) => {
          const r = this._initializeOnDelegatedTarget(o);
          r._activeTrigger[o.type === "focusout" ? Gi : ve] = r._element.contains(o.relatedTarget), r._leave();
        });
      }
    this._hideModalHandler = () => {
      this._element && this.hide();
    }, T.on(
      this._element.closest(Rn),
      Vn,
      this._hideModalHandler
    );
  }
  _fixTitle() {
    const t = this._element.getAttribute("title");
    t && (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", t), this._element.setAttribute("data-mdb-original-title", t), this._element.removeAttribute("title"));
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = !0;
      return;
    }
    this._isHovered = !0, this._setTimeout(() => {
      this._isHovered && this.show();
    }, this._config.delay.show);
  }
  _leave() {
    this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
      this._isHovered || this.hide();
    }, this._config.delay.hide));
  }
  _setTimeout(t, e) {
    clearTimeout(this._timeout), this._timeout = setTimeout(t, e);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(!0);
  }
  _getConfig(t) {
    const e = Nt.getDataAttributes(this._element);
    for (const s of Object.keys(e))
      Fd.has(s) && delete e[s];
    return t = {
      ...e,
      ...typeof t == "object" && t ? t : {}
    }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
  }
  _configAfterMerge(t) {
    return t.container = t.container === !1 ? document.body : $t(t.container), typeof t.delay == "number" && (t.delay = {
      show: t.delay,
      hide: t.delay
    }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), t;
  }
  _getDelegateConfig() {
    const t = {};
    for (const [e, s] of Object.entries(this._config))
      this.constructor.Default[e] !== s && (t[e] = s);
    return t.selector = !1, t.trigger = "manual", t;
  }
  _disposePopper() {
    this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = pa.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const oh = "popover", rh = ".popover-header", ah = ".popover-body", lh = {
  ...Ni.Default,
  content: "",
  offset: [0, 8],
  placement: "right",
  template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  trigger: "click"
}, ch = {
  ...Ni.DefaultType,
  content: "(null|string|element|function)"
};
let dh = class fa extends Ni {
  // Getters
  static get Default() {
    return lh;
  }
  static get DefaultType() {
    return ch;
  }
  static get NAME() {
    return oh;
  }
  // Overrides
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }
  // Private
  _getContentForTemplate() {
    return {
      [rh]: this._getTitle(),
      [ah]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = fa.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const Hn = "popover", hh = "show.bs.popover", uh = "shown.bs.popover", ph = "hide.bs.popover", fh = "hidden.bs.popover", _h = "inserted.bs.popover", mh = [
  { name: "show" },
  { name: "shown" },
  { name: "hide" },
  { name: "hidden" },
  { name: "inserted" }
];
class Im extends dh {
  constructor(t, e) {
    super(t, e), this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this.element, hh), u.off(this.element, uh), u.off(this.element, ph), u.off(this.element, fh), u.off(this.element, _h), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Hn;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    u.extend(this._element, mh, Hn);
  }
}
const gh = "scrollspy", bh = "bs.scrollspy", _a = `.${bh}`, Eh = `activate${_a}`, Bn = `click${_a}`, vh = "dropdown-item", qt = "active", qi = "[href]", Th = ".nav, .list-group", Fn = ".nav-link", Ch = ".nav-item", Ah = ".list-group-item", yh = `${Fn}, ${Ch} > ${Fn}, ${Ah}`, Oh = ".dropdown", Sh = ".dropdown-toggle", wh = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "0px 0px -25%",
  smoothScroll: !1,
  target: null,
  threshold: [0.1, 0.5, 1]
}, Nh = {
  offset: "(number|null)",
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "string",
  smoothScroll: "boolean",
  target: "element",
  threshold: "array"
};
let Dh = class ma extends ht {
  constructor(t, e) {
    super(t, e), this._config.target && (this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    }, this.refresh());
  }
  // Getters
  static get Default() {
    return wh;
  }
  static get DefaultType() {
    return Nh;
  }
  static get NAME() {
    return gh;
  }
  // Public
  refresh() {
    this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
    for (const t of this._observableSections.values())
      this._observer.observe(t);
  }
  dispose() {
    this._observer && this._observer.disconnect(), super.dispose();
  }
  // Private
  _configAfterMerge(t) {
    return t.target = $t(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, typeof t.threshold == "string" && (t.threshold = t.threshold.split(",").map((e) => Number.parseFloat(e))), t;
  }
  _maybeEnableSmoothScroll() {
    this._config.smoothScroll && (T.off(this._config.target, Bn), T.on(this._config.target, Bn, qi, (t) => {
      const e = this._observableSections.get(t.target.hash);
      if (e) {
        t.preventDefault();
        const s = this._rootElement || window, n = e.offsetTop - this._element.offsetTop;
        if (s.scrollTo) {
          s.scrollTo({ top: n, behavior: "smooth" });
          return;
        }
        s.scrollTop = n;
      }
    }));
  }
  _getNewObserver() {
    const t = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver((e) => this._observerCallback(e), t);
  }
  // The logic of selection
  _observerCallback(t) {
    const e = (r) => this._targetLinks.get(`#${r.target.id}`), s = (r) => {
      this._previousScrollData.visibleEntryTop = r.target.offsetTop, this._process(e(r));
    }, n = (this._rootElement || document.documentElement).scrollTop, o = n >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = n;
    for (const r of t) {
      if (!r.isIntersecting) {
        this._activeTarget = null, this._clearActiveClass(e(r));
        continue;
      }
      const a = r.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      if (o && a) {
        if (s(r), !n)
          return;
        continue;
      }
      !o && !a && s(r);
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
    const t = k.find(qi, this._config.target);
    for (const e of t) {
      if (!e.hash || oe(e))
        continue;
      const s = k.findOne(decodeURI(e.hash), this._element);
      yi(s) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, s));
    }
  }
  _process(t) {
    this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(qt), this._activateParents(t), T.trigger(this._element, Eh, { relatedTarget: t }));
  }
  _activateParents(t) {
    if (t.classList.contains(vh)) {
      k.findOne(
        Sh,
        t.closest(Oh)
      ).classList.add(qt);
      return;
    }
    for (const e of k.parents(t, Th))
      for (const s of k.prev(e, yh))
        s.classList.add(qt);
  }
  _clearActiveClass(t) {
    t.classList.remove(qt);
    const e = k.find(
      `${qi}.${qt}`,
      t
    );
    for (const s of e)
      s.classList.remove(qt);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = ma.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const ga = "scrollspy", $h = `mdb.${ga}`, Mh = `.${$h}`, Wn = "activate.bs.scrollspy", Lh = `activate${Mh}`, ba = "collapsible-scrollspy", kh = "active", Xi = "ul", Ih = `.${kh}`, Yn = `.${ba}`;
class xm extends Dh {
  constructor(t, e) {
    super(t, e), this._collapsibles = [], this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._scrollElement, Wn), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return ga;
  }
  // Private
  _init() {
    this._bindActivateEvent(), this._getCollapsibles(), this._collapsibles.length !== 0 && (this._showSubsection(), this._hideSubsection());
  }
  _getHeight(t) {
    return t.offsetHeight;
  }
  _hide(t) {
    const e = p.findOne(Xi, t.parentNode);
    e.style.overflow = "hidden", e.style.height = "0px";
  }
  _show(t, e) {
    t.style.height = e;
  }
  _getCollapsibles() {
    const t = p.find(Yn);
    t && t.forEach((e) => {
      const s = e.parentNode, n = p.findOne(Xi, s), o = n.offsetHeight;
      this._collapsibles.push({
        element: n,
        relatedTarget: e.getAttribute("href"),
        height: `${o}px`
      });
    });
  }
  _showSubsection() {
    p.find(Ih).filter((s) => c.hasClass(s, ba)).forEach((s) => {
      const n = p.findOne(Xi, s.parentNode), o = this._collapsibles.find((r) => r.relatedTarget = s.getAttribute("href")).height;
      this._show(n, o);
    });
  }
  _hideSubsection() {
    p.find(Yn).filter((e) => c.hasClass(e, "active") === !1).forEach((e) => {
      this._hide(e);
    });
  }
  _bindActivateEvent() {
    u.on(this._element, Wn, (t) => {
      this._showSubsection(), this._hideSubsection(), u.trigger(this._element, Lh, {
        relatedTarget: t.relatedTarget
      });
    });
  }
}
const xh = "tab", Ph = "bs.tab", Ie = `.${Ph}`, Rh = `hide${Ie}`, Vh = `hidden${Ie}`, Hh = `show${Ie}`, Bh = `shown${Ie}`, Fh = `keydown${Ie}`, Wh = "ArrowLeft", jn = "ArrowRight", Yh = "ArrowUp", Kn = "ArrowDown", Qi = "Home", Un = "End", Ke = "active", zn = "fade", Zi = "show", jh = "dropdown", Ea = ".dropdown-toggle", Kh = ".dropdown-menu", Ji = `:not(${Ea})`, Uh = '.list-group, .nav, [role="tablist"]', zh = ".nav-item, .list-group-item", Gh = `.nav-link${Ji}, .list-group-item${Ji}, [role="tab"]${Ji}`, qh = "[data-mdb-tab-initialized]", ts = `${Gh}, ${qh}`;
let Xh = class Ss extends ht {
  constructor(t) {
    super(t), this._parent = this._element.closest(Uh), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), T.on(this._element, Fh, (e) => this._keydown(e)));
  }
  // Getters
  static get NAME() {
    return xh;
  }
  // Public
  show() {
    const t = this._element;
    if (this._elemIsActive(t))
      return;
    const e = this._getActiveElem(), s = e ? T.trigger(e, Rh, { relatedTarget: t }) : null;
    T.trigger(t, Hh, { relatedTarget: e }).defaultPrevented || s && s.defaultPrevented || (this._deactivate(e, t), this._activate(t, e));
  }
  // Private
  _activate(t, e) {
    if (!t)
      return;
    t.classList.add(Ke), this._activate(k.getElementFromSelector(t));
    const s = () => {
      if (t.getAttribute("role") !== "tab") {
        t.classList.add(Zi);
        return;
      }
      t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), T.trigger(t, Bh, {
        relatedTarget: e
      });
    };
    this._queueCallback(s, t, t.classList.contains(zn));
  }
  _deactivate(t, e) {
    if (!t)
      return;
    t.classList.remove(Ke), t.blur(), this._deactivate(k.getElementFromSelector(t));
    const s = () => {
      if (t.getAttribute("role") !== "tab") {
        t.classList.remove(Zi);
        return;
      }
      t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), T.trigger(t, Vh, { relatedTarget: e });
    };
    this._queueCallback(s, t, t.classList.contains(zn));
  }
  _keydown(t) {
    if (![Wh, jn, Yh, Kn, Qi, Un].includes(
      t.key
    ))
      return;
    t.stopPropagation(), t.preventDefault();
    const e = this._getChildren().filter((n) => !oe(n));
    let s;
    if ([Qi, Un].includes(t.key))
      s = e[t.key === Qi ? 0 : e.length - 1];
    else {
      const n = [jn, Kn].includes(t.key);
      s = Is(e, t.target, n, !0);
    }
    s && (s.focus({ preventScroll: !0 }), Ss.getOrCreateInstance(s).show());
  }
  _getChildren() {
    return k.find(ts, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find((t) => this._elemIsActive(t)) || null;
  }
  _setInitialAttributes(t, e) {
    this._setAttributeIfNotExists(t, "role", "tablist");
    for (const s of e)
      this._setInitialAttributesOnChild(s);
  }
  _setInitialAttributesOnChild(t) {
    t = this._getInnerElement(t);
    const e = this._elemIsActive(t), s = this._getOuterElement(t);
    t.setAttribute("aria-selected", e), s !== t && this._setAttributeIfNotExists(s, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t);
  }
  _setInitialAttributesOnTargetPanel(t) {
    const e = k.getElementFromSelector(t);
    e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`));
  }
  _toggleDropDown(t, e) {
    const s = this._getOuterElement(t);
    if (!s.classList.contains(jh))
      return;
    const n = (o, r) => {
      const a = k.findOne(o, s);
      a && a.classList.toggle(r, e);
    };
    n(Ea, Ke), n(Kh, Zi), s.setAttribute("aria-expanded", e);
  }
  _setAttributeIfNotExists(t, e, s) {
    t.hasAttribute(e) || t.setAttribute(e, s);
  }
  _elemIsActive(t) {
    return t.classList.contains(Ke);
  }
  // Try to get the inner element (usually the .nav-link)
  _getInnerElement(t) {
    return t.matches(ts) ? t : k.findOne(ts, t);
  }
  // Try to get the outer element (usually the .nav-item)
  _getOuterElement(t) {
    return t.closest(zh) || t;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Ss.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const va = "tab", Qh = `mdb.${va}`, Di = `.${Qh}`, Gn = "show.bs.tab", qn = "shown.bs.tab", Zh = "hide.bs.tab", Jh = "hidden.bs.tab", tu = `show${Di}`, eu = `shown${Di}`, iu = `hide${Di}`, su = `hidden${Di}`, Xn = "active", Qn = "fade", Zn = "show";
class Pm extends Xh {
  constructor(t) {
    super(t), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._element, Gn), u.off(this._element, qn), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return va;
  }
  // Override
  show() {
    const t = this._element;
    if (this._elemIsActive(t))
      return;
    const e = this._getActiveElem();
    let s = null, n = null;
    e && (s = u.trigger(e, Zh, { relatedTarget: t }), n = u.trigger(e, iu, { relatedTarget: t }));
    const o = u.trigger(t, Gn, { relatedTarget: e }), r = u.trigger(t, tu, { relatedTarget: e });
    o.defaultPrevented || r.defaultPrevented || s && s.defaultPrevented || n && n.defaultPrevented || (this._deactivate(e, t), this._activate(t, e));
  }
  _activate(t, e) {
    if (!t)
      return;
    t.classList.add(Xn), this._activate(ne(t));
    const s = () => {
      if (t.getAttribute("role") !== "tab") {
        t.classList.add(Zn);
        return;
      }
      t.focus(), t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), u.trigger(t, qn, {
        relatedTarget: e
      }), u.trigger(t, eu, {
        relatedTarget: e
      });
    };
    this._queueCallback(s, t, t.classList.contains(Qn));
  }
  _deactivate(t, e) {
    if (!t)
      return;
    t.classList.remove(Xn), t.blur(), this._deactivate(ne(t));
    const s = () => {
      if (t.getAttribute("role") !== "tab") {
        t.classList.remove(Zn);
        return;
      }
      t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), u.trigger(t, Jh, { relatedTarget: e }), u.trigger(t, su, { relatedTarget: e });
    };
    this._queueCallback(s, t, t.classList.contains(Qn));
  }
}
const Jn = "tooltip", nu = "hide.bs.tooltip", ou = "hidden.bs.tooltip", ru = "show.bs.tooltip", au = "shown.bs.tooltip", lu = "inserted.bs.tooltip", cu = [
  { name: "show" },
  { name: "shown" },
  { name: "hide" },
  { name: "hidden" },
  { name: "inserted" }
];
class Rm extends Ni {
  constructor(t, e) {
    super(t, e), this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._element, ru), u.off(this._element, au), u.off(this._element, nu), u.off(this._element, ou), u.off(this._element, lu), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Jn;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    u.extend(this._element, cu, Jn);
  }
}
(() => {
  var i = { 454: (s, n, o) => {
    o.d(n, { Z: () => l });
    var r = o(645), a = o.n(r)()(function(d) {
      return d[1];
    });
    a.push([s.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const l = a;
  }, 645: (s) => {
    s.exports = function(n) {
      var o = [];
      return o.toString = function() {
        return this.map(function(r) {
          var a = n(r);
          return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
        }).join("");
      }, o.i = function(r, a, l) {
        typeof r == "string" && (r = [[null, r, ""]]);
        var d = {};
        if (l)
          for (var h = 0; h < this.length; h++) {
            var f = this[h][0];
            f != null && (d[f] = !0);
          }
        for (var m = 0; m < r.length; m++) {
          var _ = [].concat(r[m]);
          l && d[_[0]] || (a && (_[2] ? _[2] = "".concat(a, " and ").concat(_[2]) : _[2] = a), o.push(_));
        }
      }, o;
    };
  }, 810: () => {
    (function() {
      if (typeof window < "u")
        try {
          var s = new window.CustomEvent("test", { cancelable: !0 });
          if (s.preventDefault(), s.defaultPrevented !== !0)
            throw new Error("Could not prevent default");
        } catch {
          var n = function(r, a) {
            var l, d;
            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), d = l.preventDefault, l.preventDefault = function() {
              d.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return !0;
                } });
              } catch {
                this.defaultPrevented = !0;
              }
            }, l;
          };
          n.prototype = window.Event.prototype, window.CustomEvent = n;
        }
    })();
  }, 379: (s, n, o) => {
    var r, a = function() {
      var E = {};
      return function(v) {
        if (E[v] === void 0) {
          var C = document.querySelector(v);
          if (window.HTMLIFrameElement && C instanceof window.HTMLIFrameElement)
            try {
              C = C.contentDocument.head;
            } catch {
              C = null;
            }
          E[v] = C;
        }
        return E[v];
      };
    }(), l = [];
    function d(E) {
      for (var v = -1, C = 0; C < l.length; C++)
        if (l[C].identifier === E) {
          v = C;
          break;
        }
      return v;
    }
    function h(E, v) {
      for (var C = {}, A = [], w = 0; w < E.length; w++) {
        var $ = E[w], S = v.base ? $[0] + v.base : $[0], D = C[S] || 0, M = "".concat(S, " ").concat(D);
        C[S] = D + 1;
        var L = d(M), I = { css: $[1], media: $[2], sourceMap: $[3] };
        L !== -1 ? (l[L].references++, l[L].updater(I)) : l.push({ identifier: M, updater: N(I, v), references: 1 }), A.push(M);
      }
      return A;
    }
    function f(E) {
      var v = document.createElement("style"), C = E.attributes || {};
      if (C.nonce === void 0) {
        var A = o.nc;
        A && (C.nonce = A);
      }
      if (Object.keys(C).forEach(function($) {
        v.setAttribute($, C[$]);
      }), typeof E.insert == "function")
        E.insert(v);
      else {
        var w = a(E.insert || "head");
        if (!w)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        w.appendChild(v);
      }
      return v;
    }
    var m, _ = (m = [], function(E, v) {
      return m[E] = v, m.filter(Boolean).join(`
`);
    });
    function g(E, v, C, A) {
      var w = C ? "" : A.media ? "@media ".concat(A.media, " {").concat(A.css, "}") : A.css;
      if (E.styleSheet)
        E.styleSheet.cssText = _(v, w);
      else {
        var $ = document.createTextNode(w), S = E.childNodes;
        S[v] && E.removeChild(S[v]), S.length ? E.insertBefore($, S[v]) : E.appendChild($);
      }
    }
    function b(E, v, C) {
      var A = C.css, w = C.media, $ = C.sourceMap;
      if (w ? E.setAttribute("media", w) : E.removeAttribute("media"), $ && typeof btoa < "u" && (A += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify($)))), " */")), E.styleSheet)
        E.styleSheet.cssText = A;
      else {
        for (; E.firstChild; )
          E.removeChild(E.firstChild);
        E.appendChild(document.createTextNode(A));
      }
    }
    var y = null, O = 0;
    function N(E, v) {
      var C, A, w;
      if (v.singleton) {
        var $ = O++;
        C = y || (y = f(v)), A = g.bind(null, C, $, !1), w = g.bind(null, C, $, !0);
      } else
        C = f(v), A = b.bind(null, C, v), w = function() {
          (function(S) {
            if (S.parentNode === null)
              return !1;
            S.parentNode.removeChild(S);
          })(C);
        };
      return A(E), function(S) {
        if (S) {
          if (S.css === E.css && S.media === E.media && S.sourceMap === E.sourceMap)
            return;
          A(E = S);
        } else
          w();
      };
    }
    s.exports = function(E, v) {
      (v = v || {}).singleton || typeof v.singleton == "boolean" || (v.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
      var C = h(E = E || [], v);
      return function(A) {
        if (A = A || [], Object.prototype.toString.call(A) === "[object Array]") {
          for (var w = 0; w < C.length; w++) {
            var $ = d(C[w]);
            l[$].references--;
          }
          for (var S = h(A, v), D = 0; D < C.length; D++) {
            var M = d(C[D]);
            l[M].references === 0 && (l[M].updater(), l.splice(M, 1));
          }
          C = S;
        }
      };
    };
  } }, t = {};
  function e(s) {
    var n = t[s];
    if (n !== void 0)
      return n.exports;
    var o = t[s] = { id: s, exports: {} };
    return i[s](o, o.exports, e), o.exports;
  }
  e.n = (s) => {
    var n = s && s.__esModule ? () => s.default : () => s;
    return e.d(n, { a: n }), n;
  }, e.d = (s, n) => {
    for (var o in n)
      e.o(n, o) && !e.o(s, o) && Object.defineProperty(s, o, { enumerable: !0, get: n[o] });
  }, e.o = (s, n) => Object.prototype.hasOwnProperty.call(s, n), (() => {
    var s = e(379), n = e.n(s), o = e(454);
    function r(l) {
      if (!l.hasAttribute("autocompleted")) {
        l.setAttribute("autocompleted", "");
        var d = new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !0, detail: null });
        l.dispatchEvent(d) || (l.value = "");
      }
    }
    function a(l) {
      l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !1, detail: null })));
    }
    n()(o.Z, { insert: "head", singleton: !1 }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
      l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
    }, !0), document.addEventListener("input", function(l) {
      l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
    }, !0);
  })();
})();
class me {
  constructor(t) {
    t = rn(t), t && (this._element = t, ct.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    ct.removeData(this._element, this.constructor.DATA_KEY), u.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  /** Static */
  static getInstance(t) {
    return ct.getData(rn(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  static get DATA_KEY() {
    return `mdb.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const du = "input", hu = "mdb.input", Ue = "active", Ta = "form-notch", Ca = "form-notch-leading", Aa = "form-notch-middle", uu = "form-notch-trailing", pu = "placeholder-active", fu = "form-helper", _u = "form-counter", to = `.${Ta}`, eo = `.${Ca}`, mu = `.${Aa}`, gu = `.${fu}`;
class Gs extends me {
  constructor(t) {
    super(t), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (this.init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor));
  }
  // Getters
  static get NAME() {
    return du;
  }
  get input() {
    return p.findOne("input", this._element) || p.findOne("textarea", this._element);
  }
  // Public
  init() {
    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._initiated = !0);
  }
  update() {
    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
  }
  forceActive() {
    c.addClass(this.input, Ue);
  }
  forceInactive() {
    c.removeClass(this.input, Ue);
  }
  dispose() {
    this._removeBorder(), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  /*
    _getIcons() {
      this._leadingIcon = SelectorEngine.findOne('i.leading', this._element);
  
      if (this._leadingIcon !== null) {
        this._applyLeadingIcon();
      }
    }
  
    _applyLeadingIcon() {
      this._label.innerHTML = ` ${this._label.innerHTML}`;
      this._label.insertBefore(this._leadingIcon, this._label.firstChild);
    }
    */
  _getLabelData() {
    this._label = p.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
  }
  _getHelper() {
    this._helper = p.findOne(gu, this._element);
  }
  _getCounter() {
    this._counter = c.getDataAttribute(this.input, "showcounter"), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
  }
  _showCounter() {
    if (p.find(".form-counter", this._element).length > 0)
      return;
    this._counterElement = document.createElement("div"), c.addClass(this._counterElement, _u);
    const e = this.input.value.length;
    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
  }
  _bindCounter() {
    u.on(this.input, "input", () => {
      const t = this.input.value.length;
      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(t = this.input) {
    if (!(t.getAttribute("type") === "date"))
      return;
    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
  }
  _showPlaceholder() {
    c.addClass(this.input, pu);
  }
  _getNotchData() {
    this._notchMiddle = p.findOne(mu, this._element), this._notchLeading = p.findOne(eo, this._element);
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    if (this._labelMarginLeft = 0, !this._element.classList.contains("input-group"))
      return;
    const t = this.input, e = p.prev(t, ".input-group-text")[0];
    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
  }
  _applyDivs() {
    const t = p.find(to, this._element), e = P("div");
    c.addClass(e, Ta), this._notchLeading = P("div"), c.addClass(this._notchLeading, Ca), this._notchMiddle = P("div"), c.addClass(this._notchMiddle, Aa), this._notchTrailing = P("div"), c.addClass(this._notchTrailing, uu), !(t.length >= 1) && (e.append(this._notchLeading), e.append(this._notchMiddle), e.append(this._notchTrailing), this._element.append(e));
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _removeBorder() {
    const t = p.findOne(to, this._element);
    t && t.remove();
  }
  _activate(t) {
    pr(() => {
      this._getElements(t);
      const e = t ? t.target : this.input;
      e.value !== "" && c.addClass(e, Ue), this._toggleDefaultDatePlaceholder(e);
    });
  }
  _getElements(t) {
    if (t && (this._element = t.target.parentNode, this._label = p.findOne("label", this._element)), t && this._label) {
      const e = this._labelWidth;
      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = p.findOne(".form-notch-middle", t.target.parentNode), this._notchLeading = p.findOne(
        eo,
        t.target.parentNode
      ), this._applyNotch());
    }
  }
  _deactivate(t) {
    const e = t ? t.target : this.input;
    e.value === "" && e.classList.remove(Ue), this._toggleDefaultDatePlaceholder(e);
  }
  static activate(t) {
    return function(e) {
      t._activate(e);
    };
  }
  static deactivate(t) {
    return function(e) {
      t._deactivate(e);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = ct.getData(this, hu);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Gs(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const bu = "collapse", Eu = "bs.collapse", $i = `.${Eu}`, vu = `show${$i}`, Tu = `shown${$i}`, Cu = `hide${$i}`, Au = `hidden${$i}`, es = "show", ee = "collapse", ze = "collapsing", yu = "collapsed", Ou = `:scope .${ee} .${ee}`, Su = "collapse-horizontal", wu = "width", Nu = "height", Du = ".collapse.show, .collapse.collapsing", io = "[data-mdb-collapse-init]", $u = {
  parent: null,
  toggle: !0
}, Mu = {
  parent: "(null|element)",
  toggle: "boolean"
};
let Lu = class ws extends ht {
  constructor(t, e) {
    super(t, e), this._isTransitioning = !1, this._triggerArray = [];
    const s = k.find(io);
    for (const n of s) {
      const o = k.getSelectorFromElement(n), r = k.find(o).filter(
        (a) => a === this._element
      );
      o !== null && r.length && this._triggerArray.push(n);
    }
    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
  }
  // Getters
  static get Default() {
    return $u;
  }
  static get DefaultType() {
    return Mu;
  }
  static get NAME() {
    return bu;
  }
  // Public
  toggle() {
    this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (this._isTransitioning || this._isShown())
      return;
    let t = [];
    if (this._config.parent && (t = this._getFirstLevelChildren(Du).filter((a) => a !== this._element).map((a) => ws.getOrCreateInstance(a, { toggle: !1 }))), t.length && t[0]._isTransitioning || T.trigger(this._element, vu).defaultPrevented)
      return;
    for (const a of t)
      a.hide();
    const s = this._getDimension();
    this._element.classList.remove(ee), this._element.classList.add(ze), this._element.style[s] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
    const n = () => {
      this._isTransitioning = !1, this._element.classList.remove(ze), this._element.classList.add(ee, es), this._element.style[s] = "", T.trigger(this._element, Tu);
    }, r = `scroll${s[0].toUpperCase() + s.slice(1)}`;
    this._queueCallback(n, this._element, !0), this._element.style[s] = `${this._element[r]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown() || T.trigger(this._element, Cu).defaultPrevented)
      return;
    const e = this._getDimension();
    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, $e(this._element), this._element.classList.add(ze), this._element.classList.remove(ee, es);
    for (const n of this._triggerArray) {
      const o = k.getElementFromSelector(n);
      o && !this._isShown(o) && this._addAriaAndCollapsedClass([n], !1);
    }
    this._isTransitioning = !0;
    const s = () => {
      this._isTransitioning = !1, this._element.classList.remove(ze), this._element.classList.add(ee), T.trigger(this._element, Au);
    };
    this._element.style[e] = "", this._queueCallback(s, this._element, !0);
  }
  _isShown(t = this._element) {
    return t.classList.contains(es);
  }
  // Private
  _configAfterMerge(t) {
    return t.toggle = !!t.toggle, t.parent = $t(t.parent), t;
  }
  _getDimension() {
    return this._element.classList.contains(Su) ? wu : Nu;
  }
  _initializeChildren() {
    if (!this._config.parent)
      return;
    const t = this._getFirstLevelChildren(io);
    for (const e of t) {
      const s = k.getElementFromSelector(e);
      s && this._addAriaAndCollapsedClass([e], this._isShown(s));
    }
  }
  _getFirstLevelChildren(t) {
    const e = k.find(Ou, this._config.parent);
    return k.find(t, this._config.parent).filter(
      (s) => !e.includes(s)
    );
  }
  _addAriaAndCollapsedClass(t, e) {
    if (t.length)
      for (const s of t)
        s.classList.toggle(yu, !e), s.setAttribute("aria-expanded", e);
  }
  // Static
  static jQueryInterface(t) {
    const e = {};
    return typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1), this.each(function() {
      const s = ws.getOrCreateInstance(this, e);
      if (typeof t == "string") {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t]();
      }
    });
  }
};
const so = "collapse", ku = "show.bs.collapse", Iu = "shown.bs.collapse", xu = "hide.bs.collapse", Pu = "hidden.bs.collapse", Ru = [{ name: "show" }, { name: "shown" }, { name: "hide" }, { name: "hidden" }];
class Vm extends Lu {
  constructor(t, e = {}) {
    super(t, e), this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._element, ku), u.off(this._element, Iu), u.off(this._element, xu), u.off(this._element, Pu), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return so;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    u.extend(this._element, Ru, so);
  }
}
const no = "dropdown", Vu = "bs.dropdown", Mi = `.${Vu}`, Hu = "Escape", oo = "Tab", Bu = "ArrowUp", ro = "ArrowDown", Fu = 2, Wu = `hide${Mi}`, Yu = `hidden${Mi}`, ju = `show${Mi}`, Ku = `shown${Mi}`, te = "show", Uu = "dropup", zu = "dropend", Gu = "dropstart", qu = "dropup-center", Xu = "dropdown-center", Te = "[data-mdb-dropdown-initialized]:not(.disabled):not(:disabled)", Qu = `${Te}.${te}`, is = ".dropdown-menu", Zu = ".navbar", Ju = ".navbar-nav", tp = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", ep = at() ? "top-end" : "top-start", ip = at() ? "top-start" : "top-end", sp = at() ? "bottom-end" : "bottom-start", np = at() ? "bottom-start" : "bottom-end", op = at() ? "left-start" : "right-start", rp = at() ? "right-start" : "left-start", ap = "top", lp = "bottom", cp = {
  autoClose: !0,
  boundary: "clippingParents",
  display: "dynamic",
  offset: [0, 2],
  popperConfig: null,
  reference: "toggle"
}, dp = {
  autoClose: "(boolean|string)",
  boundary: "(string|element)",
  display: "string",
  offset: "(array|string|function)",
  popperConfig: "(null|object|function)",
  reference: "(string|element|object)"
};
let hp = class ci extends ht {
  constructor(t, e) {
    super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = k.next(this._element, is)[0] || k.prev(this._element, is)[0] || k.findOne(is, this._parent), this._inNavbar = this._detectNavbar();
  }
  // Getters
  static get Default() {
    return cp;
  }
  static get DefaultType() {
    return dp;
  }
  static get NAME() {
    return no;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (oe(this._element) || this._isShown())
      return;
    const t = {
      relatedTarget: this._element
    };
    if (!T.trigger(this._element, ju, t).defaultPrevented) {
      if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(Ju))
        for (const s of [].concat(...document.body.children))
          T.on(s, "mouseover", bi);
      this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(te), this._element.classList.add(te), T.trigger(this._element, Ku, t);
    }
  }
  hide() {
    if (oe(this._element) || !this._isShown())
      return;
    const t = {
      relatedTarget: this._element
    };
    this._completeHide(t);
  }
  dispose() {
    this._popper && this._popper.destroy(), super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
  }
  // Private
  _completeHide(t) {
    if (!T.trigger(this._element, Wu, t).defaultPrevented) {
      if ("ontouchstart" in document.documentElement)
        for (const s of [].concat(...document.body.children))
          T.off(s, "mouseover", bi);
      this._popper && this._popper.destroy(), this._menu.classList.remove(te), this._element.classList.remove(te), this._element.setAttribute("aria-expanded", "false"), Nt.removeDataAttribute(this._menu, "popper"), T.trigger(this._element, Yu, t);
    }
  }
  _getConfig(t) {
    if (t = super._getConfig(t), typeof t.reference == "object" && !Tt(t.reference) && typeof t.reference.getBoundingClientRect != "function")
      throw new TypeError(
        `${no.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    return t;
  }
  _createPopper() {
    if (typeof ha > "u")
      throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
    let t = this._element;
    this._config.reference === "parent" ? t = this._parent : Tt(this._config.reference) ? t = $t(this._config.reference) : typeof this._config.reference == "object" && (t = this._config.reference);
    const e = this._getPopperConfig();
    this._popper = _e(t, this._menu, e);
  }
  _isShown() {
    return this._menu.classList.contains(te);
  }
  _getPlacement() {
    const t = this._parent;
    if (t.classList.contains(zu))
      return op;
    if (t.classList.contains(Gu))
      return rp;
    if (t.classList.contains(qu))
      return ap;
    if (t.classList.contains(Xu))
      return lp;
    const e = getComputedStyle(this._menu).getPropertyValue("--mdb-position").trim() === "end";
    return t.classList.contains(Uu) ? e ? ip : ep : e ? np : sp;
  }
  _detectNavbar() {
    return this._element.closest(Zu) !== null;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return (this._inNavbar || this._config.display === "static") && (Nt.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      ...J(this._config.popperConfig, [t])
    };
  }
  _selectMenuItem({ key: t, target: e }) {
    const s = k.find(tp, this._menu).filter(
      (n) => yi(n)
    );
    s.length && Is(s, e, t === ro, !s.includes(e)).focus();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = ci.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static clearMenus(t) {
    if (t.button === Fu || t.type === "keyup" && t.key !== oo)
      return;
    const e = k.find(Qu);
    for (const s of e) {
      const n = ci.getInstance(s);
      if (!n || n._config.autoClose === !1)
        continue;
      const o = t.composedPath(), r = o.includes(n._menu);
      if (o.includes(n._element) || n._config.autoClose === "inside" && !r || n._config.autoClose === "outside" && r || n._menu.contains(t.target) && (t.type === "keyup" && t.key === oo || /input|select|option|textarea|form/i.test(t.target.tagName)))
        continue;
      const a = { relatedTarget: n._element };
      t.type === "click" && (a.clickEvent = t), n._completeHide(a);
    }
  }
  static dataApiKeydownHandler(t) {
    const e = /input|textarea/i.test(t.target.tagName), s = t.key === Hu, n = [Bu, ro].includes(t.key);
    if (!n && !s || e && !s)
      return;
    t.preventDefault();
    const o = this.matches(Te) ? this : k.prev(this, Te)[0] || k.next(this, Te)[0] || k.findOne(Te, t.delegateTarget.parentNode), r = ci.getOrCreateInstance(o);
    if (n) {
      t.stopPropagation(), r.show(), r._selectMenuItem(t);
      return;
    }
    r._isShown() && (t.stopPropagation(), r.hide(), o.focus());
  }
};
const Ns = "dropdown", up = `mdb.${Ns}`, Li = `.${up}`, pp = {
  offset: [0, 2],
  flip: !0,
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  dropdownAnimation: "on"
}, fp = {
  offset: "(array|string|function)",
  flip: "boolean",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  dropdownAnimation: "string"
}, ao = "hide.bs.dropdown", lo = "hidden.bs.dropdown", co = "show.bs.dropdown", ho = "shown.bs.dropdown", _p = `hide${Li}`, mp = `hidden${Li}`, gp = `show${Li}`, bp = `shown${Li}`, ss = "animation", ns = "fade-in", os = "fade-out";
class Hm extends hp {
  constructor(t, e) {
    super(t, e), this._config = this._getConfig(e), this._menuStyle = "", this._popperPlacement = "", this._mdbPopperConfig = "";
    const s = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    this._config.dropdownAnimation === "on" && !s && this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._element, co), u.off(this._parent, ho), u.off(this._parent, ao), u.off(this._parent, lo), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Ns;
  }
  // Private
  _init() {
    this._bindShowEvent(), this._bindShownEvent(), this._bindHideEvent(), this._bindHiddenEvent();
  }
  _getConfig(t) {
    const e = {
      ...pp,
      ...c.getDataAttributes(this._element),
      ...t
    };
    return De(Ns, e, fp), e;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            altBoundary: this._config.flip,
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return this._config.display === "static" && (c.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      /* eslint no-extra-parens: "off" */
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
    };
  }
  _bindShowEvent() {
    u.on(this._element, co, (t) => {
      if (u.trigger(this._element, gp, {
        relatedTarget: t.relatedTarget
      }).defaultPrevented) {
        t.preventDefault();
        return;
      }
      this._dropdownAnimationStart("show");
    });
  }
  _bindShownEvent() {
    u.on(this._parent, ho, (t) => {
      if (u.trigger(this._parent, bp, {
        relatedTarget: t.relatedTarget
      }).defaultPrevented) {
        t.preventDefault();
        return;
      }
    });
  }
  _bindHideEvent() {
    u.on(this._parent, ao, (t) => {
      if (u.trigger(this._parent, _p, {
        relatedTarget: t.relatedTarget
      }).defaultPrevented) {
        t.preventDefault();
        return;
      }
      this._menuStyle = this._menu.style.cssText, this._popperPlacement = this._menu.getAttribute("data-popper-placement"), this._mdbPopperConfig = this._menu.getAttribute("data-mdb-popper");
    });
  }
  _bindHiddenEvent() {
    u.on(this._parent, lo, (t) => {
      if (u.trigger(this._parent, mp, {
        relatedTarget: t.relatedTarget
      }).defaultPrevented) {
        t.preventDefault();
        return;
      }
      this._config.display !== "static" && this._menuStyle !== "" && (this._menu.style.cssText = this._menuStyle), this._menu.setAttribute("data-popper-placement", this._popperPlacement), this._menu.setAttribute("data-mdb-popper", this._mdbPopperConfig), this._dropdownAnimationStart("hide");
    });
  }
  _dropdownAnimationStart(t) {
    switch (t) {
      case "show":
        this._menu.classList.add(ss, ns), this._menu.classList.remove(os);
        break;
      default:
        this._menu.classList.add(ss, os), this._menu.classList.remove(ns);
        break;
    }
    this._bindAnimationEnd();
  }
  _bindAnimationEnd() {
    u.one(this._menu, "animationend", () => {
      this._menu.classList.remove(ss, os, ns);
    });
  }
}
const Ds = "ripple", Ep = "mdb.ripple", bt = "ripple-surface", uo = "ripple-wave", po = "input-wrapper", vp = ".btn", Tp = [vp, `[data-mdb-${Ds}-init]`], fo = "ripple-surface-unbound", Cp = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", Ge = [0, 0, 0], Ap = [
  "primary",
  "secondary",
  "success",
  "danger",
  "warning",
  "info",
  "light",
  "dark"
], _o = 0.5, yp = {
  rippleCentered: !1,
  rippleColor: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: !1
}, Op = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
};
class ya extends me {
  constructor(t, e) {
    super(t), this._options = this._getConfig(e), this._element && (c.addClass(this._element, bt), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._rippleInSpan = !1, this.init();
  }
  // Getters
  static get NAME() {
    return Ds;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    u.off(this._element, "mousedown", this._clickHandler), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _autoInit(t) {
    Tp.forEach((s) => {
      p.closest(t.target, s) && (this._element = p.closest(t.target, s));
    });
    const e = c.getDataAttributes(this._element);
    if (!(this._element.classList.contains("btn") && e.rippleInit === !1)) {
      if (this._options = this._getConfig(), this._element.tagName.toLowerCase() === "input") {
        const s = this._element.parentNode;
        if (this._rippleInSpan = !0, s.tagName.toLowerCase() === "span" && s.classList.contains(bt))
          this._element = s;
        else {
          const n = getComputedStyle(this._element).boxShadow, o = this._element, r = document.createElement("span");
          o.classList.contains("btn-block") && (r.style.display = "block"), u.one(r, "mouseup", (a) => {
            a.button === 0 && o.click();
          }), r.classList.add(bt, po), c.addStyle(r, {
            border: 0,
            "box-shadow": n
          }), s.replaceChild(r, this._element), r.appendChild(this._element), this._element = r;
        }
        this._element.focus();
      }
      this._element.style.minWidth || (c.style(this._element, { "min-width": `${getComputedStyle(this._element).width}` }), this._isMinWidthSet = !0), c.addClass(this._element, bt), this._createRipple(t);
    }
  }
  _addClickEvent(t) {
    u.on(t, "mousedown", this._clickHandler);
  }
  _getEventLayer(t) {
    const e = Math.round(t.clientX - t.target.getBoundingClientRect().x), s = Math.round(t.clientY - t.target.getBoundingClientRect().y);
    return { layerX: e, layerY: s };
  }
  _createRipple(t) {
    if (this._element === null)
      return;
    c.hasClass(this._element, bt) || c.addClass(this._element, bt);
    const { layerX: e, layerY: s } = this._getEventLayer(t), n = e, o = s, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), d = {
      offsetX: this._options.rippleCentered ? r / 2 : n,
      offsetY: this._options.rippleCentered ? a / 2 : o,
      height: r,
      width: a
    }, h = this._getDiameter(d), f = this._options.rippleRadius || h / 2, m = {
      delay: l * _o,
      duration: l - l * _o
    }, _ = {
      left: this._options.rippleCentered ? `${a / 2 - f}px` : `${n - f}px`,
      top: this._options.rippleCentered ? `${r / 2 - f}px` : `${o - f}px`,
      height: `${this._options.rippleRadius * 2 || h}px`,
      width: `${this._options.rippleRadius * 2 || h}px`,
      transitionDelay: `0s, ${m.delay}ms`,
      transitionDuration: `${l}ms, ${m.duration}ms`
    }, g = P("div");
    this._createHTMLRipple({ wrapper: this._element, ripple: g, styles: _ }), this._removeHTMLRipple({ ripple: g, duration: l });
  }
  _createHTMLRipple({ wrapper: t, ripple: e, styles: s }) {
    Object.keys(s).forEach((n) => e.style[n] = s[n]), e.classList.add(uo), this._options.rippleColor !== "" && (this._removeOldColorClasses(t), this._addColor(e, t)), this._toggleUnbound(t), this._appendRipple(e, t);
  }
  _removeHTMLRipple({ ripple: t, duration: e }) {
    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), this._rippleTimer = setTimeout(() => {
      t && (t.remove(), this._element && (p.find(`.${uo}`, this._element).forEach((s) => {
        s.remove();
      }), this._isMinWidthSet && (c.style(this._element, { "min-width": "" }), this._isMinWidthSet = !1), this._rippleInSpan && this._element.classList.contains(po) ? this._removeWrapperSpan() : c.removeClass(this._element, bt)));
    }, e);
  }
  _removeWrapperSpan() {
    const t = this._element.firstChild;
    this._element.replaceWith(t), this._element = t, this._element.focus(), this._rippleInSpan = !1;
  }
  _durationToMsNumber(t) {
    return Number(t.replace("ms", "").replace("s", "000"));
  }
  _getConfig(t = {}) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...yp,
      ...e,
      ...t
    }, De(Ds, t, Op), t;
  }
  _getDiameter({ offsetX: t, offsetY: e, height: s, width: n }) {
    const o = e <= s / 2, r = t <= n / 2, a = (m, _) => Math.sqrt(m ** 2 + _ ** 2), l = e === s / 2 && t === n / 2, d = {
      first: o === !0 && r === !1,
      second: o === !0 && r === !0,
      third: o === !1 && r === !0,
      fourth: o === !1 && r === !1
    }, h = {
      topLeft: a(t, e),
      topRight: a(n - t, e),
      bottomLeft: a(t, s - e),
      bottomRight: a(n - t, s - e)
    };
    let f = 0;
    return l || d.fourth ? f = h.topLeft : d.third ? f = h.topRight : d.second ? f = h.bottomRight : d.first && (f = h.bottomLeft), f * 2;
  }
  _appendRipple(t, e) {
    e.appendChild(t), setTimeout(() => {
      c.addClass(t, "active");
    }, 50);
  }
  _toggleUnbound(t) {
    this._options.rippleUnbound === !0 ? c.addClass(t, fo) : t.classList.remove(fo);
  }
  _addColor(t, e) {
    if (Ap.find(
      (n) => n === this._options.rippleColor.toLowerCase()
    ))
      c.addClass(
        e,
        `${bt}-${this._options.rippleColor.toLowerCase()}`
      );
    else {
      const n = this._colorToRGB(this._options.rippleColor).join(","), o = Cp.split("{{color}}").join(`${n}`);
      t.style.backgroundImage = `radial-gradient(circle, ${o})`;
    }
  }
  _removeOldColorClasses(t) {
    const e = new RegExp(`${bt}-[a-z]+`, "gi");
    (t.classList.value.match(e) || []).forEach((n) => {
      t.classList.remove(n);
    });
  }
  _colorToRGB(t) {
    function e(o) {
      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
        parseInt(o.substr(1, 2), 16),
        parseInt(o.substr(3, 2), 16),
        parseInt(o.substr(5, 2), 16)
      ];
    }
    function s(o) {
      const r = document.body.appendChild(document.createElement("fictum")), a = "rgb(1, 2, 3)";
      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === "") ? Ge : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
    }
    function n(o) {
      return o = o.match(/[.\d]+/g).map((r) => +Number(r)), o.length = 3, o;
    }
    return t.toLowerCase() === "transparent" ? Ge : t[0] === "#" ? e(t) : (t.indexOf("rgb") === -1 && (t = s(t)), t.indexOf("rgb") === 0 ? n(t) : Ge);
  }
  // Static
  static autoInitial(t) {
    return function(e) {
      t._autoInit(e);
    };
  }
  static jQueryInterface(t) {
    return this.each(function() {
      return ct.getData(this, Ep) ? null : new ya(this, t);
    });
  }
}
const Sp = "range", wp = "mdb.range", Oa = "thumb", mo = "thumb-active", Np = "thumb-value", Dp = `.${Np}`, $p = `.${Oa}`;
class Sa extends me {
  constructor(t) {
    super(t), this._initiated = !1, this._thumb = null, this._element && (this.init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor));
  }
  // Getters
  static get NAME() {
    return Sp;
  }
  get rangeInput() {
    return p.findOne("input[type=range]", this._element);
  }
  // Public
  init() {
    this._initiated || (this._addThumb(), this._thumbUpdate(), this._handleEvents(), this._initiated = !0);
  }
  dispose() {
    this._disposeEvents(), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _addThumb() {
    const t = P("span");
    c.addClass(t, Oa), t.innerHTML = '<span class="thumb-value"></span>', this._element.append(t), this._thumb = p.findOne($p, this._element);
  }
  _handleEvents() {
    u.on(this.rangeInput, "mousedown", () => this._showThumb()), u.on(this.rangeInput, "mouseup", () => this._hideThumb()), u.on(this.rangeInput, "touchstart", () => this._showThumb()), u.on(this.rangeInput, "touchend", () => this._hideThumb()), u.on(this.rangeInput, "input", () => this._thumbUpdate());
  }
  _disposeEvents() {
    u.off(this.rangeInput, "mousedown"), u.off(this.rangeInput, "mouseup"), u.off(this.rangeInput, "touchstart"), u.off(this.rangeInput, "touchend"), u.off(this.rangeInput, "input");
  }
  _showThumb() {
    c.addClass(this._thumb, mo);
  }
  _hideThumb() {
    c.removeClass(this._thumb, mo);
  }
  _thumbUpdate() {
    const t = this.rangeInput, e = t.value, s = t.min ? t.min : 0, n = t.max ? t.max : 100, o = p.findOne(Dp, this._thumb);
    o.textContent = e;
    const r = Number((e - s) * 100 / (n - s));
    c.style(this._thumb, { left: `calc(${r}% + (${8 - r * 0.15}px))` });
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = ct.getData(this, wp);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Sa(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const Mp = "modal", Lp = "bs.modal", dt = `.${Lp}`, kp = "Escape", Ip = `hide${dt}`, xp = `hidePrevented${dt}`, Pp = `hidden${dt}`, Rp = `show${dt}`, Vp = `shown${dt}`, Hp = `resize${dt}`, Bp = `click.dismiss${dt}`, Fp = `mousedown.dismiss${dt}`, Wp = `keydown.dismiss${dt}`, go = "modal-open", Yp = "fade", bo = "show", rs = "modal-static", jp = ".modal-dialog", Kp = ".modal-body", Up = {
  backdrop: !0,
  focus: !0,
  keyboard: !0
}, zp = {
  backdrop: "(boolean|string)",
  focus: "boolean",
  keyboard: "boolean"
};
let Gp = class wa extends ht {
  constructor(t, e) {
    super(t, e), this._dialog = k.findOne(jp, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Ne(), this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Up;
  }
  static get DefaultType() {
    return zp;
  }
  static get NAME() {
    return Mp;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    this._isShown || this._isTransitioning || T.trigger(this._element, Rp, {
      relatedTarget: t
    }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(go), this._adjustDialog(), this._backdrop.show(() => this._showElement(t)));
  }
  hide() {
    !this._isShown || this._isTransitioning || T.trigger(this._element, Ip).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(bo), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()));
  }
  dispose() {
    T.off(window, dt), T.off(this._dialog, dt), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new xr({
      isVisible: !!this._config.backdrop && !this._config.modalNonInvasive,
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new Pr({
      trapElement: this._element
    });
  }
  _showElement(t) {
    document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
    const e = k.findOne(Kp, this._dialog);
    e && (e.scrollTop = 0), $e(this._element), this._element.classList.add(bo);
    const s = () => {
      this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, T.trigger(this._element, Vp, {
        relatedTarget: t
      });
    };
    this._queueCallback(s, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    T.on(this._element, Wp, (t) => {
      if (t.key === kp) {
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      }
    }), T.on(window, Hp, () => {
      this._isShown && !this._isTransitioning && this._adjustDialog();
    }), T.on(this._element, Fp, (t) => {
      T.one(this._element, Bp, (e) => {
        if (!(this._element !== t.target || this._element !== e.target)) {
          if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
            return;
          }
          this._config.backdrop && this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
      document.body.classList.remove(go), this._resetAdjustments(), this._scrollBar.reset(), T.trigger(this._element, Pp);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(Yp);
  }
  _triggerBackdropTransition() {
    if (T.trigger(this._element, xp).defaultPrevented)
      return;
    const e = this._element.scrollHeight > document.documentElement.clientHeight, s = this._element.style.overflowY;
    s === "hidden" || this._element.classList.contains(rs) || (e || (this._element.style.overflowY = "hidden"), this._element.classList.add(rs), this._queueCallback(() => {
      this._element.classList.remove(rs), this._queueCallback(() => {
        this._element.style.overflowY = s;
      }, this._dialog);
    }, this._dialog), this._element.focus());
  }
  /**
   * The following methods are used to handle overflowing modals
   */
  _adjustDialog() {
    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), s = e > 0;
    if (s && !t) {
      const n = at() ? "paddingLeft" : "paddingRight";
      this._element.style[n] = `${e}px`;
    }
    if (!s && t) {
      const n = at() ? "paddingRight" : "paddingLeft";
      this._element.style[n] = `${e}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const s = wa.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
};
const Eo = "modal", qp = "hide.bs.modal", Xp = "hidePrevented.bs.modal", Qp = "hidden.bs.modal", Zp = "show.bs.modal", Jp = "shown.bs.modal", tf = [
  { name: "show", parametersToCopy: ["relatedTarget"] },
  { name: "shown", parametersToCopy: ["relatedTarget"] },
  { name: "hide" },
  { name: "hidePrevented" },
  { name: "hidden" }
];
class Bm extends Gp {
  constructor(t, e) {
    super(t, e), this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._element, Zp), u.off(this._element, Jp), u.off(this._element, qp), u.off(this._element, Qp), u.off(this._element, Xp), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Eo;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    u.extend(this._element, tf, Eo);
  }
}
const ef = "toast", sf = "bs.toast", Lt = `.${sf}`, nf = `mouseover${Lt}`, of = `mouseout${Lt}`, rf = `focusin${Lt}`, af = `focusout${Lt}`, lf = `hide${Lt}`, cf = `hidden${Lt}`, df = `show${Lt}`, hf = `shown${Lt}`, uf = "fade", vo = "hide", qe = "show", Xe = "showing", pf = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, ff = {
  animation: !0,
  autohide: !0,
  delay: 5e3
};
let _f = class Na extends ht {
  constructor(t, e) {
    super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
  }
  // Getters
  static get Default() {
    return ff;
  }
  static get DefaultType() {
    return pf;
  }
  static get NAME() {
    return ef;
  }
  // Public
  show() {
    if (T.trigger(this._element, df).defaultPrevented)
      return;
    this._clearTimeout(), this._config.animation && this._element.classList.add(uf);
    const e = () => {
      this._element.classList.remove(Xe), T.trigger(this._element, hf), this._maybeScheduleHide();
    };
    this._element.classList.remove(vo), $e(this._element), this._element.classList.add(qe, Xe), this._queueCallback(e, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown() || T.trigger(this._element, lf).defaultPrevented)
      return;
    const e = () => {
      this._element.classList.add(vo), this._element.classList.remove(Xe, qe), T.trigger(this._element, cf);
    };
    this._element.classList.add(Xe), this._queueCallback(e, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout(), this.isShown() && this._element.classList.remove(qe), super.dispose();
  }
  isShown() {
    return this._element.classList.contains(qe);
  }
  // Private
  _maybeScheduleHide() {
    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay)));
  }
  _onInteraction(t, e) {
    switch (t.type) {
      case "mouseover":
      case "mouseout": {
        this._hasMouseInteraction = e;
        break;
      }
      case "focusin":
      case "focusout": {
        this._hasKeyboardInteraction = e;
        break;
      }
    }
    if (e) {
      this._clearTimeout();
      return;
    }
    const s = t.relatedTarget;
    this._element === s || this._element.contains(s) || this._maybeScheduleHide();
  }
  _setListeners() {
    T.on(this._element, nf, (t) => this._onInteraction(t, !0)), T.on(this._element, of, (t) => this._onInteraction(t, !1)), T.on(this._element, rf, (t) => this._onInteraction(t, !0)), T.on(this._element, af, (t) => this._onInteraction(t, !1));
  }
  _clearTimeout() {
    clearTimeout(this._timeout), this._timeout = null;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Na.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
};
const To = "toast", mf = "show.bs.toast", gf = "shown.bs.toast", bf = "hide.bs.toast", Ef = "hidden.bs.toast", vf = [{ name: "show" }, { name: "shown" }, { name: "hide" }, { name: "hidden" }];
class Fm extends _f {
  constructor(t, e) {
    super(t, e), this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._element, mf), u.off(this._element, gf), u.off(this._element, bf), u.off(this._element, Ef), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return To;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    u.extend(this._element, vf, To);
  }
}
const Tf = "alert", Cf = "bs.alert", Da = `.${Cf}`, Af = `close${Da}`, yf = `closed${Da}`, Of = "fade", Sf = "show";
let wf = class $a extends ht {
  // Getters
  static get NAME() {
    return Tf;
  }
  // Public
  close() {
    if (T.trigger(this._element, Af).defaultPrevented)
      return;
    this._element.classList.remove(Sf);
    const e = this._element.classList.contains(Of);
    this._queueCallback(() => this._destroyElement(), this._element, e);
  }
  // Private
  _destroyElement() {
    this._element.remove(), T.trigger(this._element, yf), this.dispose();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = $a.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
};
const Co = "alert", Nf = "close.bs.alert", Df = "closed.bs.alert", $f = [{ name: "close" }, { name: "closed" }];
class Wm extends wf {
  constructor(t, e = {}) {
    super(t, e), this._init(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  dispose() {
    u.off(this._element, Nf), u.off(this._element, Df), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Co;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    u.extend(this._element, $f, Co);
  }
}
const Mf = ({
  format24: i,
  okLabel: t,
  cancelLabel: e,
  headId: s,
  footerId: n,
  bodyId: o,
  pickerId: r,
  clearLabel: a,
  inline: l,
  showClearBtn: d,
  amLabel: h,
  pmLabel: f
}) => {
  const m = `<div id='${r}' class='timepicker-wrapper h-100 d-flex align-items-center justify-content-center flex-column position-fixed'>
               <div class="d-flex align-items-center justify-content-center flex-column timepicker-container">
                  <div class="d-flex flex-column timepicker-elements justify-content-around">
                  <div id='${s}' class='timepicker-head d-flex flex-row align-items-center justify-content-center'
                  style='padding-right:${i ? 50 : 0}px'>
                  <div class='timepicker-head-content d-flex w-100 justify-content-evenly'>
                      <div class="timepicker-current-wrapper">
                        <span class="position-relative h-100">
                          <button type='button' class='timepicker-current timepicker-hour active ripple' tabindex="0">21</button>
                        </span>
                        <button type='button' class='timepicker-dot' disabled>:</button>
                      <span class="position-relative h-100">
                        <button type='button' class='timepicker-current timepicker-minute ripple' tabindex="0">21</button>
                      </span>
                      </div>
                      ${i ? "" : `<div class="d-flex flex-column justify-content-center timepicker-mode-wrapper">
                              <button type='button' class="timepicker-hour-mode timepicker-am ripple" tabindex="0">${h}</button>
                              <button class="timepicker-hour-mode timepicker-pm ripple" tabindex="0">${f}</button>
                            </div>`}
                  </div>
                </div>
                ${l ? "" : `<div id='${o}' class='timepicker-clock-wrapper d-flex justify-content-center flex-column align-items-center'>
                        <div class='timepicker-clock'>
                          <span class='timepicker-middle-dot position-absolute'></span>
                          <div class='timepicker-hand-pointer position-absolute'>
                            <div class='timepicker-circle position-absolute'></div>
                          </div>
                          ${i ? '<div class="timepicker-clock-inner"></div>' : ""}
                         </div>
                      </div>`}

              </div>
                <div id='${n}' class='timepicker-footer'>
                  <div class="w-100 d-flex justify-content-between">
                    ${d ? `<button type='button' class='timepicker-button timepicker-clear ripple' tabindex="0">${a}</button>` : ""}
                    <button type='button' class='timepicker-button timepicker-cancel ripple' tabindex="0">${e}</button>
                    <button type='button' class='timepicker-button timepicker-submit ripple' tabindex="0">${t}</button>
                  </div>
                </div>
              </div>
        </div>`, _ = `<div id='${r}' class='timepicker-wrapper h-100 d-flex align-items-center justify-content-center flex-column timepicker-wrapper-inline'>
               <div class="d-flex align-items-center justify-content-center flex-column timepicker-container">
                  <div class="d-flex flex-column timepicker-elements justify-content-around timepicker-elements-inline">
                  <div id='${s}' class='timepicker-head d-flex flex-row align-items-center justify-content-center timepicker-head-inline'
                  style='padding-right:0px'>
                  <div class='timepicker-head-content d-flex w-100 justify-content-evenly align-items-center'>
                      <div class="timepicker-current-wrapper">
                        <span class="position-relative h-100 timepicker-inline-hour-icons">
                          <i class="fas fa-chevron-up position-absolute text-white timepicker-icon-up timepicker-icon-inline-hour"></i>
                          <button type='button' class='timepicker-current timepicker-hour active ripple timepicker-current-inline' tabindex="0">21</button>
                          <i class="fas fa-chevron-down position-absolute text-white timepicker-icon-down timepicker-icon-inline-hour"></i>
                        </span>
                        <button type='button' class='timepicker-dot timepicker-current-inline' disabled>:</button>
                      <span class="position-relative h-100  timepicker-inline-minutes-icons">
                        <i class="fas fa-chevron-up position-absolute text-white timepicker-icon-up timepicker-icon-inline-minute"></i>
                        <button type='button' class='timepicker-current timepicker-minute ripple timepicker-current-inline' tabindex="0">21</button>
                        <i class="fas fa-chevron-down position-absolute text-white timepicker-icon-down timepicker-icon-inline-minute"></i>
                      </span>
                      </div>
                      ${i ? "" : `<div class="d-flex justify-content-center timepicker-mode-wrapper">
                              <button type='button' class="timepicker-hour-mode timepicker-am ripple me-2 ms-4" tabindex="0">${h}</button>
                              <button class="timepicker-hour-mode timepicker-pm ripple" tabindex="0">${f}</button>
                              <button type='button' class='timepicker-button timepicker-submit timepicker-submit-inline ripple py-1 px-2 mb-0' tabindex="0">${t}</button>
                            </div>`}
                      ${i ? `<button class='timepicker-button timepicker-submit timepicker-submit-inline ripple py-1 px-2 mb-0' tabindex="0">${t}</button>` : ""}
                  </div>
                </div>
              </div>
           </div>
        </div>
  `;
  return l ? _ : m;
}, Lf = (i, t) => {
  const { iconClass: e } = i;
  return `
  <button id="${t}" tabindex="0" type="button" class="timepicker-toggle-button" data-mdb-toggle="timepicker"  >
    <i class="${e}"></i>
  </button>
`;
}, Dt = (i) => {
  if (i === "")
    return;
  let t, e, s, n;
  return Ma(i) ? (t = i.getHours(), n = t, e = i.getMinutes(), t %= 12, t === 0 ? s = "AM" : t > 12 && (s = "PM"), t = t || 12, s === void 0 && (s = t >= 12 ? "PM" : "AM"), e = e < 10 ? `0${e}` : e) : ([t, e, s] = V(i, !1), n = t, t %= 12, t === 0 && s === void 0 && (s = "AM"), t = t || 12, s === void 0 && (s = n >= 12 ? "PM" : "AM")), {
    hours: t,
    minutes: e,
    amOrPm: s
  };
}, Ma = (i) => i && Object.prototype.toString.call(i) === "[object Date]" && !isNaN(i), as = (i) => {
  if (i === "")
    return;
  let t, e;
  return Ma(i) ? (t = i.getHours(), e = i.getMinutes()) : [t, e] = V(i, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {
    hours: t,
    minutes: e
  };
}, kf = (i, t) => u.on(document, i, t, ({ target: e }) => {
  c.hasClass(e, "active") || (document.querySelectorAll(t).forEach((n) => {
    c.hasClass(n, "active") && c.removeClass(n, "active");
  }), c.addClass(e, "active"));
}), Ao = ({ clientX: i, clientY: t, touches: e }, s, n = !1) => {
  const { left: o, top: r } = s.getBoundingClientRect();
  let a = {};
  return !n || !e ? a = {
    x: i - o,
    y: t - r
  } : n && Object.keys(e).length > 0 && (a = {
    x: e[0].clientX - o,
    y: e[0].clientY - r
  }), a;
}, Qe = () => {
  let i = !1;
  return (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) && (i = !0), i;
}, V = (i, t = !0) => {
  let e;
  return t ? e = i.value.replace(/:/gi, " ") : e = i.replace(/:/gi, " "), e.split(" ");
}, La = (i, t) => {
  const [e, s, n] = V(i, !1), [o, r, a] = V(t, !1), l = n == a;
  if (n == "PM" && a == "AM")
    return 1;
  if (n == "AM" && a == "PM")
    return 2;
  if (l && e > o)
    return 1;
  if (e < o)
    return 2;
  if (s > r)
    return 1;
  if (s < r)
    return 2;
}, ka = () => {
  const i = /* @__PURE__ */ new Date(), t = i.getHours();
  let e = String(i.getMinutes());
  return e.length === 1 && (e = `0${e}`), `${t}:${e}`;
}, St = (i, t, e) => {
  if (!t)
    return i;
  let s = ka();
  return e && (s = `${Dt(s).hours}:${Dt(s).minutes} ${Dt(s).amOrPm}`), (i != "" && La(s, i) == 1 || i === "") && (i = s), i;
}, wt = (i, t, e) => {
  if (!t)
    return i;
  let s = ka();
  return e && (s = `${Dt(s).hours}:${Dt(s).minutes} ${Dt(s).amOrPm}`), (i != "" && La(s, i) == 2 || i === "") && (i = s), i;
}, If = ({ format12: i, maxTime: t, minTime: e, disablePast: s, disableFuture: n }, o, r, a) => {
  const l = V(o)[1];
  e = St(e, s, i), t = wt(t, n, i);
  const [d, h, f] = V(t, !1), [m, _, g] = V(e, !1);
  if (f === void 0 && g === void 0) {
    if (f === void 0) {
      if (d !== "" && m === "") {
        if (Number(r) > Number(d) || h !== "" && _ === void 0 && Number(r) > Number(d))
          return;
      } else if (d === "" && m !== "" && h === void 0 && _ !== "" && (Number(r) < Number(m) || Number(r) < Number(m) && a < Number(_)))
        return;
    } else if (g === void 0) {
      if (d !== "" && m === "") {
        if (Number(r) > Number(d) || h !== "" && _ === void 0 && (Number(r) > Number(d) || a > Number(h)))
          return;
      } else if (d === "" && m !== "" && h === void 0 && _ !== "" && (Number(r) < Number(m) || a < Number(_)))
        return;
    }
  }
  return [r, l];
}, yo = (i, t) => {
  i.forEach((e) => {
    (e.textContent === "00" || Number(e.textContent) > t) && c.addClass(e, "disabled");
  });
}, Oo = (i, t) => {
  i.forEach((e) => {
    e.textContent !== "00" && Number(e.textContent) < t && c.addClass(e, "disabled");
  });
}, xf = (i, t, e, s) => {
  i.forEach((n) => {
    Number(n.textContent) > t && Number(s) == e && c.addClass(n, "disabled");
  });
}, Pf = (i, t, e, s) => {
  i.forEach((n) => {
    Number(n.textContent) < t && Number(s) == e && c.addClass(n, "disabled");
  });
}, Rf = (i) => {
  let t;
  return i.startsWith("0") ? t = Number(i.slice(1)) : t = Number(i), t;
};
class Ia {
  constructor(t, e = {}, s) {
    this._element = t, this._toggler = s, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {
      this._condition(n) && n.target === this._lastElement && (n.preventDefault(), this._firstElement.focus());
    };
  }
  trap() {
    this._setElements(), this._init(), this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((t) => {
      t.removeEventListener(this._event, this.handler);
    }), this._toggler && this._toggler.focus();
  }
  update() {
    this._setElements(), this._setFocusTrap();
  }
  _init() {
    const t = (e) => {
      !this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", t));
    };
    window.addEventListener("keydown", t);
  }
  _filterVisible(t) {
    return t.filter((e) => {
      if (!Ai(e))
        return !1;
      const s = p.parents(e, "*");
      for (let n = 0; n < s.length; n++) {
        const o = window.getComputedStyle(s[n]);
        if (o && (o.display === "none" || o.visibility === "hidden"))
          return !1;
      }
      return !0;
    });
  }
  _setElements() {
    const t = p.find(this._selector, this._element);
    this._focusableElements = t.filter((e) => {
      const s = e.getAttribute("data-mdb-disabled") === "true" || e.hasAttribute("disabled");
      return e.disabled || s ? null : e;
    }), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((t, e) => {
      e === this._focusableElements.length - 1 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);
    });
  }
}
const di = 37, ot = 38, hi = 39, Z = 40, ye = 36, Oe = 35, ls = 33, cs = 34, vt = 13, ds = 32, qs = 27, So = 9, x = "timepicker", xa = `mdb.${x}`, ut = `.${xa}`, gt = ".data-api", wo = `click${ut}${gt}`, Ze = `keydown${ut}${gt}`, No = `mousedown${ut}${gt}`, Do = `mouseup${ut}${gt}`, $o = `mousemove${ut}${gt}`, Mo = `mouseleave${ut}${gt}`, Lo = `mouseover${ut}${gt}`, ko = `touchmove${ut}${gt}`, Io = `touchend${ut}${gt}`, xo = `touchstart${ut}${gt}`, Vf = `valueChanged${ut}`, B = "active", Hf = `${x}-am`, hs = `${x}-cancel`, Po = `${x}-clear`, Ro = `${x}-submit`, us = `${x}-circle`, Bf = `${x}-clock-animation`, Pt = `${x}-clock`, Je = `${x}-clock-inner`, Vo = `${x}-clock-wrapper`, ps = `.${x}-current`, Ff = `${x}-current-inline`, Wf = "fade-in", Yf = "fade-out", fs = `${x}-hand-pointer`, ti = `${x}-hour`, ei = `${x}-hour-mode`, Ho = `${x}-icon-down`, jf = `${x}-icon-inline-hour`, Kf = `${x}-icon-inline-minute`, Bo = `${x}-icon-up`, Fo = `${x}-inline-hour-icons`, Wo = `${x}-middle-dot`, Yo = `${x}-minute`, jo = `${x}-modal`, Uf = `${x}-pm`, _s = `${x}-tips-element`, j = `${x}-time-tips-hours`, Ko = `${x}-tips-inner-element`, nt = `${x}-time-tips-inner`, K = `${x}-time-tips-minutes`, ms = `${x}-transform`, gs = `${x}-wrapper`, zf = `${x}-input`, Gf = {
  bodyId: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: !0,
  closeModalOnMinutesClick: !1,
  container: "body",
  defaultTime: "",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  focusInputAfterApprove: !1,
  footerId: "",
  format12: !0,
  format24: !1,
  headId: "",
  increment: !1,
  inline: !1,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalId: "",
  okLabel: "Ok",
  overflowHidden: !0,
  pickerId: "",
  readOnly: !1,
  showClearBtn: !0,
  switchHoursToMinutesOnClick: !0,
  iconClass: "far fa-clock fa-sm timepicker-icon",
  withIcon: !0,
  pmLabel: "PM",
  amLabel: "AM",
  animations: !0
}, qf = {
  bodyId: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  footerId: "string",
  format12: "boolean",
  format24: "boolean",
  headId: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalId: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerId: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconClass: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
};
class Pa extends me {
  constructor(e, s = {}) {
    super(e);
    pt(this, "_toggleAmPm", (e) => {
      e == "PM" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : e == "AM" && (this._isPmEnabled = !1, this._isAmEnabled = !0);
    });
    pt(this, "_toggleBackgroundColorCircle", (e) => {
      if (this._modal.querySelector(`.${e}.${B}`) !== null) {
        c.addClass(this._circle, "active");
        return;
      }
      c.removeClass(this._circle, "active");
    });
    pt(this, "_toggleClassActive", (e, { textContent: s }, n) => {
      const o = [...e].find((r) => Number(r) === Number(s));
      return n.forEach((r) => {
        c.hasClass(r, "disabled") || (r.textContent === o ? c.addClass(r, B) : c.removeClass(r, B));
      });
    });
    pt(this, "_makeMinutesDegrees", (e, s) => {
      const { increment: n } = this._options;
      return e < 0 ? (s = Math.round(360 + e / 6) % 60, e = 360 + Math.round(e / 6) * 6) : (s = Math.round(e / 6) % 60, e = Math.round(e / 6) * 6), n && (e = Math.round(e / 30) * 30, s = Math.round(e / 6) * 6 / 6, s === 60 && (s = "00")), e >= 360 && (e = 0), {
        degrees: e,
        minute: s,
        addDegrees: n ? 30 : 6
      };
    });
    pt(this, "_makeHourDegrees", (e, s, n) => {
      if (e)
        return this._hasTargetInnerClass(e) ? s < 0 ? (n = Math.round(360 + s / 30) % 24, s = 360 + s) : (n = Math.round(s / 30) + 12, n === 12 && (n = "00")) : s < 0 ? (n = Math.round(360 + s / 30) % 12, s = 360 + s) : (n = Math.round(s / 30) % 12, (n === 0 || n > 12) && (n = 12)), s >= 360 && (s = 0), {
          degrees: s,
          hour: n,
          addDegrees: 30
        };
    });
    pt(this, "_makeInnerHoursDegrees", (e, s) => (e < 0 ? (s = Math.round(360 + e / 30) % 24, e = 360 + e) : (s = Math.round(e / 30) + 12, s === 12 && (s = "00")), {
      degrees: e,
      hour: s,
      addDegrees: 30
    }));
    pt(this, "_getAppendClock", (e = [], s = `.${Pt}`, n) => {
      let { minTime: o, maxTime: r } = this._options;
      const { inline: a, format12: l, disablePast: d, disableFuture: h } = this._options;
      o = St(o, d, l), r = wt(r, h, l);
      const [f, m, _] = V(r, !1), [g, b, y] = V(o, !1);
      a || l && this._isInvalidTimeFormat && !c.hasClass(this._AM, "active") && c.addClass(this._PM, "active");
      const O = p.findOne(s), N = 360 / e.length;
      function E(w) {
        return w * (Math.PI / 180);
      }
      if (O === null)
        return;
      const v = (O.offsetWidth - 32) / 2, C = (O.offsetHeight - 32) / 2, A = v - 4;
      setTimeout(() => {
        let w;
        l && (w = p.findOne(`.${ei}.${B}`).textContent), this._handleDisablingTipsMinTime(w, y, b, g), this._handleDisablingTipsMaxTime(w, _, m, f);
      }, 0), [...e].forEach((w, $) => {
        const S = E($ * N), D = P("span"), M = P("span");
        M.innerHTML = w, c.addClass(D, n);
        const L = D.offsetWidth, I = D.offsetHeight;
        return c.addStyle(D, {
          left: `${v + Math.sin(S) * A - L}px`,
          bottom: `${C + Math.cos(S) * A - I}px`
        }), e.includes("05") && c.addClass(D, `${K}`), e.includes("13") ? M.classList.add(Ko) : M.classList.add(_s), D.appendChild(M), O.appendChild(D);
      });
    });
    this._document = document, this._options = this._getConfig(s), this._currentTime = null, this._toggleButtonId = this._element.id ? `timepicker-toggle-${this._element.id}` : Vt("timepicker-toggle-"), this.hoursArray = ["12", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"], this.innerHours = ["00", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"], this.minutesArray = ["00", "05", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55"], this.input = p.findOne("input", this._element), this.dataWithIcon = e.dataset.withIcon, this.dataToggle = e.dataset.toggle, this.customIcon = p.findOne(".timepicker-toggle-button", this._element), this._checkToggleButton(), this.inputFormatShow = p.findOne("[data-mdb-timepicker-format24]", this._element), this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = p.findOne("[data-mdb-toggle]", this._element), this.toggleElement = Object.values(e.querySelector("[data-mdb-toggle]").dataset)[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._timeoutInterval = null, this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = as(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = Dt(this._inputValue)), this._options.readOnly && this.input.setAttribute("readonly", !0), this.inputFormat === "true" && this.inputFormat !== "" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = as(this._inputValue)), this._scrollBar = new Ne(), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  // Getters
  static get NAME() {
    return x;
  }
  // Public
  init() {
    const { format12: e, format24: s } = this._options;
    let n, o, r;
    if (c.addClass(this.input, zf), this._currentTime !== void 0) {
      const { hours: a, minutes: l, amOrPm: d } = this._currentTime;
      n = Number(a) < 10 ? 0 : "", o = `${n}${Number(a)}:${l}`, r = d, e ? this.input.value = `${o} ${r}` : s && (this.input.value = `${o}`);
    } else
      n = "", o = "", r = "", this.input.value = "";
    this.input.value.length > 0 && this.input.value !== "" && c.addClass(this.input, "active"), (this._options !== null || this._element !== null) && (this._listenToUserInput(), this._handleOpen(), this._listenToToggleKeydown());
  }
  dispose() {
    this._removeModal(), u.off(this._document, "click", `[data-mdb-toggle='${this.toggleElement}']`), u.off(this._element, "keydown", `[data-mdb-toggle='${this.toggleElement}']`), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), setTimeout(() => {
      super.dispose();
    }, 350 + 5);
  }
  update(e = {}) {
    this._options = this._getConfig({ ...this._options, ...e });
  }
  // private
  _checkToggleButton() {
    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === "true" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));
  }
  _appendToggleButton() {
    const e = Lf(this._options, this._toggleButtonId);
    this.input.insertAdjacentHTML("afterend", e);
  }
  _getDomElements() {
    this._hour = p.findOne(`.${ti}`), this._minutes = p.findOne(`.${Yo}`), this._AM = p.findOne(`.${Hf}`), this._PM = p.findOne(`.${Uf}`), this._wrapper = p.findOne(`.${gs}`), this._modal = p.findOne(`.${jo}`), this._hand = p.findOne(`.${fs}`), this._circle = p.findOne(`.${us}`), this._clock = p.findOne(`.${Pt}`), this._clockInner = p.findOne(`.${Je}`);
  }
  _handlerMaxMinHoursOptions(e, s, n, o, r, a) {
    if (!s && !n)
      return !0;
    const { format24: l, format12: d, disablePast: h, disableFuture: f } = this._options, { _isAmEnabled: m, _isPmEnabled: _ } = this, g = a.keyCode, b = a.target.classList.contains("timepicker-clock-inner") || a.target.classList.contains("timepicker-time-tips-inner") || a.target.classList.contains("timepicker-tips-inner-element");
    n = St(n, h, d), s = wt(s, f, d);
    let y = s !== "" ? s * 30 : "", O = n !== "" ? n * 30 : "";
    e <= 0 && (e = 360 + e);
    const N = () => {
      const $ = document.querySelectorAll(".timepicker-tips-element"), S = document.querySelectorAll(".timepicker-tips-inner-element");
      let D = Rf(this._hour.innerText), M, L, I;
      return g === ot ? L = 1 : g === Z && (L = -1), D === 12 && g === ot ? I = 1 : D === 0 && g === ot ? I = 13 : D === 0 && g === Z ? I = 23 : D === 13 && g === Z ? I = 0 : D === 1 && g === Z ? I = 12 : I = D + L, $.forEach((H) => {
        H.textContent == I && (M = H);
      }), S.forEach((H) => {
        H.textContent == I && (M = H);
      }), !M.parentElement.classList.contains("disabled");
    }, E = ($) => {
      let S = n !== "" && n > 12 ? (n - 12) * 30 : "", D = s !== "" && s > 12 ? (s - 12) * 30 : "";
      if (!(S && e < S || D && e > D || s && s < 12))
        return !0;
    };
    if (l && a.type !== "keydown" && b)
      return E();
    if (a.type === "keydown")
      return N();
    const v = !r || r === "PM" && _ || n !== "" && r === "AM" && m, C = !o || o === "PM" && _ || s !== "" && o === "AM" && m, A = () => {
      if (n) {
        if (r === "PM" && m || v && e < O)
          return;
      } else
        return !0;
      return !0;
    }, w = () => {
      if (s) {
        if (o === "AM" && _ || C && e > y)
          return;
      } else
        return !0;
      return !0;
    };
    if (A() && w())
      return !0;
  }
  _handleKeyboard() {
    u.on(this._document, Ze, "", (e) => {
      let s, n, o, { increment: r, maxTime: a, minTime: l, format12: d, disablePast: h, disableFuture: f } = this._options, [m, _] = V(l, !1), [g, b] = V(a, !1);
      m = St(m, h, d), g = wt(g, f, d);
      const y = p.findOne(`.${K}`) === null, O = p.findOne(`.${nt}`) !== null, N = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), E = p.find(`.${K}`, this._modal), v = p.find(`.${j}`, this._modal), C = p.find(`.${nt}`, this._modal);
      let A = this._makeHourDegrees(e.target, N, s).hour;
      const { degrees: w, addDegrees: $ } = this._makeHourDegrees(
        e.target,
        N,
        s
      );
      let { minute: S, degrees: D } = this._makeMinutesDegrees(
        N,
        n
      );
      const M = this._makeMinutesDegrees(N, n).addDegrees;
      let { hour: L } = this._makeInnerHoursDegrees(N, o);
      if (e.keyCode === qs) {
        const I = p.findOne(`.${hs}`, this._modal);
        u.trigger(I, "click");
      } else if (y) {
        if (O && (e.keyCode === hi && (this._isInner = !1, c.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), this._hour.textContent = this._setHourOrMinute(A > 12 ? 1 : A), this._toggleClassActive(this.hoursArray, this._hour, v), this._toggleClassActive(this.innerHours, this._hour, C)), e.keyCode === di && (this._isInner = !0, c.addStyle(this._hand, {
          height: "21.5%"
        }), this._hour.textContent = this._setHourOrMinute(
          L >= 24 || L === "00" ? 0 : L
        ), this._toggleClassActive(this.innerHours, this._hour, C), this._toggleClassActive(this.hoursArray, this._hour - 1, v))), e.keyCode === ot) {
          if (!this._handlerMaxMinHoursOptions(
            w + 30,
            g,
            m,
            b,
            _,
            e
          ))
            return;
          (() => c.addStyle(this._hand, {
            transform: `rotateZ(${w + $}deg)`
          }))(), this._isInner ? (L += 1, L === 24 ? L = 0 : (L === 25 || L === "001") && (L = 13), this._hour.textContent = this._setHourOrMinute(L), this._toggleClassActive(this.innerHours, this._hour, C)) : (A += 1, this._hour.textContent = this._setHourOrMinute(A > 12 ? 1 : A), this._toggleClassActive(this.hoursArray, this._hour, v));
        }
        if (e.keyCode === Z) {
          if (!this._handlerMaxMinHoursOptions(
            w - 30,
            g,
            m,
            b,
            _,
            e
          ))
            return;
          (() => c.addStyle(this._hand, {
            transform: `rotateZ(${w - $}deg)`
          }))(), this._isInner ? (L -= 1, L === 12 ? L = 0 : L === -1 && (L = 23), this._hour.textContent = this._setHourOrMinute(L), this._toggleClassActive(this.innerHours, this._hour, C)) : (A -= 1, this._hour.textContent = this._setHourOrMinute(A === 0 ? 12 : A), this._toggleClassActive(this.hoursArray, this._hour, v));
        }
      } else
        e.keyCode === ot && (D += M, c.addStyle(this._hand, {
          transform: `rotateZ(${D}deg)`
        }), S += 1, r && (S += 4, S === "0014" && (S = 5)), this._minutes.textContent = this._setHourOrMinute(
          S > 59 ? 0 : S
        ), this._toggleClassActive(this.minutesArray, this._minutes, E), this._toggleBackgroundColorCircle(`${K}`)), e.keyCode === Z && (D -= M, c.addStyle(this._hand, {
          transform: `rotateZ(${D}deg)`
        }), r ? S -= 5 : S -= 1, S === -1 ? S = 59 : S === -5 && (S = 55), this._minutes.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.minutesArray, this._minutes, E), this._toggleBackgroundColorCircle(`${K}`));
    });
  }
  _setActiveClassToTipsOnOpen(e, ...s) {
    if (!this._isInvalidTimeFormat)
      if (this._options.format24) {
        const n = p.find(`.${j}`, this._modal), o = p.find(`.${nt}`, this._modal);
        this._addActiveClassToTip(n, e), this._addActiveClassToTip(o, e);
      } else {
        [...s].filter((o) => (o.toLowerCase() === "pm" ? c.addClass(this._PM, B) : o.toLowerCase() === "am" ? c.addClass(this._AM, B) : (c.removeClass(this._AM, B), c.removeClass(this._PM, B)), o));
        const n = p.find(`.${j}`, this._modal);
        this._addActiveClassToTip(n, e);
      }
  }
  _setTipsAndTimesDependOnInputValue(e, s) {
    const { inline: n, format12: o } = this._options;
    if (this._isInvalidTimeFormat)
      this._hour.textContent = "12", this._minutes.textContent = "00", n || c.addStyle(this._hand, {
        transform: "rotateZ(0deg)"
      }), o && c.addClass(this._PM, B);
    else {
      const r = e > 12 ? e * 30 - 360 : e * 30;
      this._hour.textContent = e, this._minutes.textContent = s, n || (c.addStyle(this._hand, {
        transform: `rotateZ(${r}deg)`
      }), c.addClass(this._circle, "active"), (Number(e) > 12 || e === "00") && c.addStyle(this._hand, {
        height: "21.5%"
      }));
    }
  }
  _listenToToggleKeydown() {
    u.on(this._element, "keydown", `[data-mdb-toggle='${this.toggleElement}']`, (e) => {
      e.keyCode === vt && (e.preventDefault(), u.trigger(this.elementToggle, "click"));
    });
  }
  _handleOpen() {
    const e = this._getContainer();
    Ut.on(
      this._element,
      "click",
      `[data-mdb-toggle='${this.toggleElement}']`,
      (s) => {
        if (this._options === null)
          return;
        const n = c.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          c.addStyle(this.elementToggle, {
            pointerEvents: "none"
          }), this.elementToggle.blur();
          let o;
          V(this.input)[0] === "" || this._isInvalidTimeFormat ? o = ["12", "00", "PM"] : o = V(this.input);
          const { modalId: r, inline: a, format12: l } = this._options, [d, h, f] = o, m = P("div");
          if ((Number(d) > 12 || d === "00") && (this._isInner = !0), this.input.blur(), s.target.blur(), m.innerHTML = Mf(this._options), c.addClass(m, jo), m.setAttribute("role", "dialog"), m.setAttribute("tabIndex", "-1"), m.setAttribute("id", r), a ? (this._popper = _e(this.input, m, {
            placement: "bottom-start"
          }), e.appendChild(m)) : (e.appendChild(m), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : c.addClass(this._wrapper, "opacity-100"), this._setActiveClassToTipsOnOpen(d, h, f), this._appendTimes(), this._setActiveClassToTipsOnOpen(d, h, f), this._setTipsAndTimesDependOnInputValue(d, h), this.input.value === "") {
            const _ = p.find(`.${j}`, this._modal);
            l && c.addClass(this._PM, B), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(_, Number(this._hour.textContent));
          }
          this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), a ? (this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks()) : (this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard(), c.addStyle(this._hour, {
            pointerEvents: "none"
          }), c.addStyle(this._minutes, {
            pointerEvents: ""
          })), this._focusTrap = new Ia(this._wrapper, {
            event: "keydown",
            condition: ({ key: _ }) => _ === "Tab"
          }), this._focusTrap.trap();
        }, n);
      }
    );
  }
  _handleInlineClicks() {
    let e, s;
    const n = (g) => {
      let b = g;
      return b > 59 ? b = 0 : b < 0 && (b = 59), b;
    }, o = (g) => {
      let b = g;
      return this._options.format24 ? (b > 24 ? b = 1 : b < 0 && (b = 23), b > 23 && (b = 0)) : (b > 12 ? b = 1 : b < 1 && (b = 12), b > 12 && (b = 1)), b;
    }, r = (g) => {
      const b = o(g);
      this._hour.textContent = this._setHourOrMinute(b);
    }, a = (g) => {
      const b = n(g);
      this._minutes.textContent = this._setHourOrMinute(b);
    }, l = () => {
      e = o(e) + 1, r(e);
    }, d = () => {
      s = n(s) + 1, a(s);
    }, h = () => {
      e = o(e) - 1, r(e);
    }, f = () => {
      s = n(s) - 1, a(s);
    }, m = () => {
      clearInterval(this._interval), clearTimeout(this._timeoutInterval);
    }, _ = (g) => {
      m(), this._timeoutInterval = setTimeout(() => {
        this._interval = setInterval(g, 100);
      }, 500);
    };
    Ut.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `.${Bo}, .${Ho}`,
      (g) => {
        e = Number(this._hour.textContent), s = Number(this._minutes.textContent);
        const { target: b, type: y } = g, O = y === "mousedown" || y === "touchstart";
        c.hasClass(b, Bo) ? c.hasClass(b.parentNode, Fo) ? O ? _(l) : y === "mouseup" || y === "touchend" || y === "contextmenu" ? m() : l() : O ? _(d) : y === "mouseup" || y === "touchend" || y === "contextmenu" ? m() : d() : c.hasClass(b, Ho) && (c.hasClass(b.parentNode, Fo) ? O ? _(h) : y === "mouseup" || y === "touchend" ? m() : h() : O ? _(f) : y === "mouseup" || y === "touchend" ? m() : f());
      }
    ), u.on(window, Ze, (g) => {
      const b = g.code, y = document.activeElement.classList.contains("timepicker-hour"), O = document.activeElement.classList.contains("timepicker-minute"), N = document.activeElement === document.body;
      switch (e = Number(this._hour.textContent), s = Number(this._minutes.textContent), b) {
        case "ArrowUp":
          g.preventDefault(), N || y ? (this._hour.focus(), l()) : O && d();
          break;
        case "ArrowDown":
          g.preventDefault(), N || y ? (this._hour.focus(), h()) : O && f();
          break;
      }
    });
  }
  _handleClose() {
    u.on(
      this._modal,
      "click",
      `.${gs}, .${hs}, .${Po}`,
      ({ target: e }) => {
        const { closeModalOnBackdropClick: s } = this._options, n = () => {
          c.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), this._focusTrap.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();
        };
        if (c.hasClass(e, Po)) {
          this._toggleAmPm("PM"), this.input.value = "", c.removeClass(this.input, "active");
          let o;
          V(this.input)[0] === "" ? o = ["12", "00", "PM"] : o = V(this.input);
          const [r, a, l] = o;
          this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(r, a, l), this._hour.click();
        } else
          (c.hasClass(e, hs) || c.hasClass(e, gs) && s) && n();
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    Ut.on(this._modal, "click", `.${Ro}`, () => {
      let { maxTime: e, minTime: s } = this._options;
      const { format12: n, format24: o, readOnly: r, focusInputAfterApprove: a, disablePast: l, disableFuture: d } = this._options, h = this._document.querySelector(`.${ei}.${B}`), f = `${this._hour.textContent}:${this._minutes.textContent}`, m = Number(this._hour.textContent), _ = Number(this._minutes.textContent);
      s = St(s, l, n), e = wt(e, d, n);
      const [g, b, y] = V(e, !1), [O, N, E] = V(s, !1), v = m < Number(O), C = m > Number(g);
      let A = !0;
      h && (A = y === h.textContent);
      let w = !0;
      h && (w = E === h.textContent);
      const $ = _ > b && m === Number(g), S = _ < N && m === Number(O);
      if (c.addClass(this.input, "active"), c.addStyle(this.elementToggle, {
        pointerEvents: "auto"
      }), e !== "") {
        if (A && (C || $))
          return;
        if (y === "AM" && h.textContent === "PM")
          return;
      }
      s !== "" && (w && (v || S) || E === "PM" && h.textContent === "AM") || If(
        this._options,
        this.input,
        this._hour.textContent,
        this._minutes.textContent
      ) !== void 0 && (this._isInvalidTimeFormat && c.removeClass(this.input, "is-invalid"), !r && a && this.input.focus(), c.addStyle(this.elementToggle, {
        pointerEvents: "auto"
      }), o ? this.input.value = f : h === null ? this.input.value = `${f} PM` : this.input.value = `${f} ${h.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), u.trigger(this.input, Vf));
    });
  }
  _handleHoverInlineBtn() {
    Ut.on(
      this._modal,
      "mouseover mouseleave",
      `.${Ff}`,
      ({ type: e, target: s }) => {
        const n = p.find(`.${jf}`, this._modal), o = p.find(
          `.${Kf}`,
          this._modal
        );
        e === "mouseover" ? c.hasClass(s, ti) ? n.forEach((r) => c.addClass(r, B)) : o.forEach((r) => c.addClass(r, B)) : c.hasClass(s, ti) ? n.forEach((r) => c.removeClass(r, B)) : o.forEach((r) => c.removeClass(r, B));
      }
    );
  }
  _handleDocumentClickInline() {
    u.on(document, wo, ({ target: e }) => {
      this._modal && !this._modal.contains(e) && !c.hasClass(e, "timepicker-icon") && (clearInterval(this._interval), c.addStyle(this.elementToggle, {
        pointerEvents: "auto"
      }), this._removeModal());
    });
  }
  _handleSwitchHourMinute() {
    kf("click", ps), u.on(this._modal, "click", ps, () => {
      const { format24: e } = this._options, s = p.find(ps, this._modal), n = p.find(`.${K}`, this._modal), o = p.find(`.${j}`, this._modal), r = p.find(`.${nt}`, this._modal), a = Number(this._hour.textContent), l = Number(this._minutes.textContent), d = (h, f) => {
        o.forEach((_) => _.remove()), n.forEach((_) => _.remove()), c.addClass(this._hand, ms), setTimeout(() => {
          c.removeClass(this._hand, ms);
        }, 401), this._getAppendClock(h, `.${Pt}`, f);
        const m = () => {
          const _ = p.find(`.${j}`, this._modal), g = p.find(`.${K}`, this._modal);
          this._addActiveClassToTip(_, a), this._addActiveClassToTip(g, l);
        };
        if (!e)
          setTimeout(() => {
            m();
          }, 401);
        else {
          const _ = p.find(`.${nt}`, this._modal);
          setTimeout(() => {
            this._addActiveClassToTip(_, a), m();
          }, 401);
        }
      };
      s.forEach((h) => {
        c.hasClass(h, B) && (c.hasClass(h, Yo) ? (c.addClass(this._hand, ms), c.addStyle(this._hand, {
          transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
          height: "calc(40% + 1px)"
        }), e && r.length > 0 && r.forEach((f) => f.remove()), d(this.minutesArray, `${K}`), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : c.hasClass(h, ti) && (c.addStyle(this._hand, {
          transform: `rotateZ(${this._hour.textContent * 30}deg)`
        }), Number(this._hour.textContent) > 12 ? (c.addStyle(this._hand, {
          transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
          height: "21.5%"
        }), Number(this._hour.textContent) > 12 && c.addStyle(this._hand, {
          height: "21.5%"
        })) : c.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), e && this._getAppendClock(
          this.innerHours,
          `.${Je}`,
          nt
        ), r.length > 0 && r.forEach((f) => f.remove()), d(this.hoursArray, `${j}`), c.addStyle(this._hour, {
          pointerEvents: "none"
        }), c.addStyle(this._minutes, {
          pointerEvents: ""
        })));
      });
    });
  }
  _handleDisablingTipsMaxTime(e, s, n, o) {
    if (!this._options.maxTime && !this._options.disableFuture)
      return;
    const r = p.find(`.${j}`), a = p.find(`.${nt}`), l = p.find(`.${K}`);
    if (!s || s === e) {
      yo(a, o), yo(r, o), xf(
        l,
        n,
        o,
        this._hour.textContent
      );
      return;
    }
    s === "AM" && e === "PM" && (r.forEach((d) => {
      c.addClass(d, "disabled");
    }), l.forEach((d) => {
      c.addClass(d, "disabled");
    }));
  }
  _handleDisablingTipsMinTime(e, s, n, o) {
    if (!this._options.minTime && !this._options.disablePast)
      return;
    const r = p.find(`.${j}`), a = p.find(`.${nt}`), l = p.find(`.${K}`);
    !s || s === e ? (Oo(r, o), Oo(a, o), Pf(
      l,
      n,
      o,
      this._hour.textContent
    )) : s === "PM" && e === "AM" && (r.forEach((d) => c.addClass(d, "disabled")), l.forEach((d) => c.addClass(d, "disabled")));
  }
  _handleSwitchTimeMode() {
    u.on(document, "click", `.${ei}`, ({ target: e }) => {
      let { maxTime: s, minTime: n } = this._options;
      const { disablePast: o, disableFuture: r, format12: a } = this._options;
      n = St(n, o, a), s = wt(s, r, a);
      let [l, d, h] = V(s, !1), [f, m, _] = V(n, !1);
      const g = p.find(`.${j}`), b = p.find(`.${K}`);
      (() => {
        g.forEach((O) => {
          c.removeClass(O, "disabled");
        }), b.forEach((O) => {
          c.removeClass(O, "disabled");
        });
      })(), this._handleDisablingTipsMinTime(
        e.textContent,
        _,
        m,
        f
      ), this._handleDisablingTipsMaxTime(
        e.textContent,
        h,
        d,
        l
      ), this._toggleAmPm(e.textContent), c.hasClass(e, B) || (p.find(`.${ei}`).forEach((N) => {
        c.hasClass(N, B) && c.removeClass(N, B);
      }), c.addClass(e, B));
    });
  }
  _handleClockClick() {
    let { maxTime: e, minTime: s } = this._options;
    const { disablePast: n, disableFuture: o, format12: r } = this._options;
    s = St(s, n, r), e = wt(e, o, r);
    const a = V(e, !1)[2], l = V(s, !1)[2], d = V(e, !1)[0], h = V(s, !1)[0], f = p.findOne(`.${Vo}`);
    Ut.on(
      document,
      `${No} ${Do} ${$o} ${Mo} ${Lo} ${xo} ${ko} ${Io}`,
      "",
      (m) => {
        Qe() || m.preventDefault();
        const { type: _, target: g } = m, { closeModalOnMinutesClick: b, switchHoursToMinutesOnClick: y } = this._options, O = p.findOne(`.${K}`, this._modal) !== null, N = p.findOne(`.${j}`, this._modal) !== null, E = p.findOne(`.${nt}`, this._modal) !== null, v = p.find(`.${K}`, this._modal), C = Ao(m, f), A = f.offsetWidth / 2;
        let w = Math.atan2(C.y - A, C.x - A);
        if (Qe()) {
          const M = Ao(m, f, !0);
          w = Math.atan2(M.y - A, M.x - A);
        }
        let $ = null, S = null, D = null;
        if (_ === "mousedown" || _ === "mousemove" || _ === "touchmove" || _ === "touchstart")
          (_ === "mousedown" || _ === "touchstart" || _ === "touchmove") && (this._hasTargetInnerClass(g) || c.hasClass(g, Vo) || c.hasClass(g, Pt) || c.hasClass(g, K) || c.hasClass(g, j) || c.hasClass(g, us) || c.hasClass(g, fs) || c.hasClass(g, Wo) || c.hasClass(g, _s)) && (this._isMouseMove = !0, Qe() && m.touches && ($ = m.touches[0].clientX, S = m.touches[0].clientY, D = document.elementFromPoint($, S)));
        else if (_ === "mouseup" || _ === "touchend") {
          if (this._isMouseMove = !1, this._hasTargetInnerClass(g) || c.hasClass(g, Pt) || c.hasClass(g, j) || c.hasClass(g, us) || c.hasClass(g, fs) || c.hasClass(g, Wo) || c.hasClass(g, _s)) {
            if ((N || E) && y) {
              const M = Number(this._hour.textContent) > d || Number(this._hour.textContent) < h;
              if (this._options.format24 && d != "" && h != "" && M)
                return;
              if (this._options.format24 && d != "" && this._hour.textContent > d)
                return;
              if (this._options.format24 && h != "" && this._hour.textContent < h)
                return;
            }
            c.hasClass(this._minutes, B) || u.trigger(this._minutes, "click");
          }
          if (O && b) {
            const M = p.findOne(`.${Ro}`, this._modal);
            u.trigger(M, "click");
          }
        }
        if (O) {
          let M;
          const L = Math.trunc(w * 180 / Math.PI) + 90, { degrees: I, minute: H } = this._makeMinutesDegrees(
            L,
            M
          );
          if (this._handlerMaxMinMinutesOptions(I, H) === void 0)
            return;
          const { degrees: q, minute: W } = this._handlerMaxMinMinutesOptions(
            I,
            H
          );
          if (this._isMouseMove) {
            if (c.addStyle(this._hand, {
              transform: `rotateZ(${q}deg)`
            }), W === void 0)
              return;
            const tt = () => W >= 10 || W === "00" ? W : `0${W}`;
            this._minutes.textContent = tt(), this._toggleClassActive(this.minutesArray, this._minutes, v), this._toggleBackgroundColorCircle(`${K}`), this._objWithDataOnChange.degreesMinutes = q, this._objWithDataOnChange.minutes = W;
          }
        }
        if (N || E) {
          let M, L = Math.trunc(w * 180 / Math.PI) + 90;
          if (L = Math.round(L / 30) * 30, c.addClass(this._circle, "active"), this._makeHourDegrees(g, L, M) === void 0)
            return;
          const I = () => {
            if (Qe() && L && D) {
              const { degrees: H, hour: q } = this._makeHourDegrees(
                D,
                L,
                M
              );
              return this._handleMoveHand(D, q, H);
            } else {
              const { degrees: H, hour: q } = this._makeHourDegrees(
                g,
                L,
                M
              );
              return this._handleMoveHand(g, q, H);
            }
          };
          this._objWithDataOnChange.degreesHours = L, this._handlerMaxMinHoursOptions(
            L,
            d,
            h,
            a,
            l,
            m
          ) && I();
        }
        m.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(e) {
    return c.hasClass(e, Je) || c.hasClass(e, nt) || c.hasClass(e, Ko);
  }
  _handleMoveHand(e, s, n) {
    const o = p.find(`.${j}`, this._modal), r = p.find(`.${nt}`, this._modal);
    this._isMouseMove && (this._hasTargetInnerClass(e) ? c.addStyle(this._hand, {
      height: "21.5%"
    }) : c.addStyle(this._hand, {
      height: "calc(40% + 1px)"
    }), c.addStyle(this._hand, {
      transform: `rotateZ(${n}deg)`
    }), this._hour.textContent = s >= 10 || s === "00" ? s : `0${s}`, this._toggleClassActive(this.hoursArray, this._hour, o), this._toggleClassActive(this.innerHours, this._hour, r), this._objWithDataOnChange.hour = s >= 10 || s === "00" ? s : `0${s}`);
  }
  _handlerMaxMinMinutesOptions(e, s) {
    let { maxTime: n, minTime: o } = this._options;
    const { format12: r, increment: a, disablePast: l, disableFuture: d } = this._options;
    o = St(o, l, r), n = wt(n, d, r);
    const h = V(n, !1)[1], f = V(o, !1)[1], m = V(n, !1)[0], _ = V(o, !1)[0], g = V(n, !1)[2], b = V(o, !1)[2], y = h !== "" ? h * 6 : "", O = f !== "" ? f * 6 : "", N = Number(this._hour.textContent);
    if (!g && !b) {
      if (n !== "" && o !== "") {
        if (m == N && e > y || _ == N && e < O)
          return e;
      } else if (o !== "" && N <= Number(_)) {
        if (e <= O - 6)
          return e;
      } else if (n !== "" && N >= Number(m) && e >= y + 6)
        return e;
    } else {
      if (o !== "") {
        if (b === "PM" && this._isAmEnabled)
          return;
        if (b === "PM" && this._isPmEnabled) {
          if (N < Number(_))
            return;
          if (N <= Number(_) && e <= O - 6)
            return e;
        } else if (b === "AM" && this._isAmEnabled) {
          if (N < Number(_))
            return;
          if (N <= Number(_) && e <= O - 6)
            return e;
        }
      }
      if (n !== "") {
        if (g === "AM" && this._isPmEnabled)
          return;
        if (g === "PM" && this._isPmEnabled) {
          if (N >= Number(m) && e >= y + 6)
            return e;
        } else if (g === "AM" && this._isAmEnabled && N >= Number(m) && e >= y + 6)
          return e;
      }
    }
    return a && (e = Math.round(e / 30) * 30), e <= 0 ? e = 360 + e : e >= 360 && (e = 0), {
      degrees: e,
      minute: s
    };
  }
  _removeModal() {
    this._animations ? setTimeout(() => {
      this._removeModalElements(), this._scrollBar.reset();
    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), Ut.off(
      this._document,
      `${wo} ${Ze} ${No} ${Do} ${$o} ${Mo} ${Lo} ${xo} ${ko} ${Io}`
    ), u.off(window, Ze);
  }
  _removeModalElements() {
    this._modal && this._modal.remove();
  }
  _toggleBackdropAnimation(e = !1) {
    e ? (c.addClass(this._wrapper, "animation"), c.addClass(this._wrapper, Yf), this._wrapper.style.animationDuration = "300ms") : (c.addClass(this._wrapper, "animation"), c.addClass(this._wrapper, Wf), this._wrapper.style.animationDuration = "300ms", this._options.inline || c.addClass(this._clock, Bf));
  }
  _addActiveClassToTip(e, s) {
    e.forEach((n) => {
      Number(n.textContent) === Number(s) && c.addClass(n, B);
    });
  }
  _setHourOrMinute(e) {
    return e < 10 ? `0${e}` : e;
  }
  _appendTimes() {
    const { format24: e } = this._options;
    e ? (this._getAppendClock(this.hoursArray, `.${Pt}`, `${j}`), this._getAppendClock(this.innerHours, `.${Je}`, nt)) : this._getAppendClock(this.hoursArray, `.${Pt}`, `${j}`);
  }
  _getConfig(e) {
    const s = c.getDataAttributes(this._element);
    return e = {
      ...Gf,
      ...s,
      ...e
    }, De(x, e, qf), e;
  }
  _getContainer() {
    return p.findOne(this._options.container);
  }
  _listenToUserInput() {
    u.on(this.input, "input", (e) => {
      this._handleUserInput(e.target.value);
    });
  }
  _handleUserInput(e) {
    const { format24: s, format12: n } = this._options;
    if (this.input.value === "")
      return;
    const o = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/, r = /^(?:[01]\d|2[0-3]):[0-5]\d$/, a = o.test(e);
    r.test(e) === !0 && s ? (this._isInvalidTimeFormat = !1, this._inputValue = this.input.value, this._currentTime = as(this._inputValue)) : a === !0 && n ? (this._isInvalidTimeFormat = !1, this._inputValue = this.input.value, this._currentTime = Dt(this._inputValue)) : this._isInvalidTimeFormat = !0;
  }
  // Static
  static jQueryInterface(e) {
    return this.each(function() {
      let s = ct.getData(this, xa);
      const n = typeof e == "object" && e;
      if (!(!s && /dispose|hide/.test(e)) && (s || (s = new Pa(this, n)), typeof e == "string")) {
        if (typeof s[e] > "u")
          throw new TypeError(`No method named "${e}"`);
        s[e]();
      }
    });
  }
}
function U(i) {
  return i.getDate();
}
function ui(i) {
  return i.getDay();
}
function F(i) {
  return i.getMonth();
}
function R(i) {
  return i.getFullYear();
}
function Xf(i, t, e) {
  const s = e.startDay, n = s > 0 ? 7 - s : 0, r = new Date(i, t).getDay() + n;
  return r >= 7 ? r - 7 : r;
}
function $s(i) {
  return Qf(i).getDate();
}
function Qf(i) {
  return _t(i.getFullYear(), i.getMonth() + 1, 0);
}
function se() {
  return /* @__PURE__ */ new Date();
}
function X(i, t) {
  return Q(i, t * 12);
}
function Q(i, t) {
  const e = _t(i.getFullYear(), i.getMonth() + t, i.getDate()), s = U(i), n = U(e);
  return s !== n && e.setDate(0), e;
}
function Xt(i, t) {
  return _t(i.getFullYear(), i.getMonth(), i.getDate() + t);
}
function _t(i, t, e) {
  const s = new Date(i, t, e);
  return i >= 0 && i < 100 && s.setFullYear(s.getFullYear() - 1900), s;
}
function Uo(i) {
  const t = i.split("-"), e = t[0], s = t[1], n = t[2];
  return _t(e, s, n);
}
function Zf(i) {
  return !Number.isNaN(i.getTime());
}
function ie(i, t) {
  return R(i) - R(t) || F(i) - F(t) || U(i) - U(t);
}
function Rt(i, t) {
  return i.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), i.getTime() === t.getTime();
}
function pi(i, t) {
  const s = R(i) - t_();
  return Jf(s, t);
}
function Jf(i, t) {
  return (i % t + t) % t;
}
function t_(i, t, e) {
  let s = 0;
  return e ? s = R(e) - i + 1 : t && (s = R(t)), s;
}
function Se(i, t, e, s, n, o) {
  const r = /* @__PURE__ */ new Date();
  r.setHours(0, 0, 0, 0);
  const a = t && ie(i, t) <= -1, l = e && ie(i, e) >= 1, d = n && ie(i, r) <= -1, h = o && ie(i, r) >= 1, f = s && s(i) === !1;
  return a || l || f || d || h;
}
function Ra(i, t, e, s, n, o) {
  const r = /* @__PURE__ */ new Date(), a = s && R(s), l = s && F(s), d = e && R(e), h = e && F(e), f = R(r), m = F(r), _ = l && a && (t > a || t === a && i > l), g = h && d && (t < d || t === d && i < h), b = n && (t < f || t === f && i < m), y = o && (t > f || t === f && i > m);
  return _ || g || b || y;
}
function Ms(i, t, e, s, n) {
  const o = t && R(t), r = e && R(e), a = R(/* @__PURE__ */ new Date()), l = r && i > r, d = o && i < o, h = s && i < a, f = n && i > a;
  return l || d || h || f;
}
function e_(i, t, e, s, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (i && o && ie(o, l) < 0 || i) && (o = l), o && we(
    t,
    o,
    e,
    s,
    n,
    o,
    r,
    a
  );
}
function i_(i, t, e, s, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (i && n && ie(n, l) < 0 || i) && (n = l), n && we(
    t,
    n,
    e,
    s,
    n,
    o,
    r,
    a
  );
}
function we(i, t, e, s, n, o, r, a) {
  return e === "days" ? R(i) === R(t) && F(i) === F(t) : e === "months" ? R(i) === R(t) : e === "years" ? R(t) >= a && R(t) <= r : !1;
}
function s_(i, t, e, s, n, o, r, a, l) {
  const d = F(i), h = R(i), f = U(i), m = ui(i), _ = P("div"), g = `
        ${zo(
    i,
    d,
    h,
    t,
    e,
    s,
    n,
    o,
    r,
    a
  )}
    `, b = `
      ${o_(f, m, d, n, i)}
      ${zo(
    i,
    d,
    h,
    t,
    e,
    s,
    n,
    o,
    r,
    a
  )}
    `;
  return n.inline ? (c.addClass(_, "datepicker-dropdown-container"), c.addClass(_, `datepicker-dropdown-container-${l}`), _.innerHTML = g) : (c.addClass(_, "datepicker-modal-container"), c.addClass(_, `datepicker-modal-container-${l}`), _.innerHTML = b), _;
}
function n_() {
  const i = P("div");
  return c.addClass(i, "datepicker-backdrop"), i;
}
function Va(i, t, e, s, n) {
  const { weekdaysShort: o, weekdaysFull: r, monthsShort: a, headerTemplateModifier: l, headerTemplate: d } = n, h = l ? l(s) : s;
  return d.replaceAll("[day]", i).replaceAll("[weekday]", o[t]).replaceAll("[weekdayFull]", r[t]).replaceAll("[month]", a[e]).replaceAll("[selected]", h);
}
function o_(i, t, e, s, n) {
  return `
      <div class="datepicker-header">
      ${s.headerTemplate ? Va(i, t, e, n, s) : `
        <div class="datepicker-title">
          <span class="datepicker-title-text">${s.title}</span>
        </div>
        <div class="datepicker-date">
          <span class="datepicker-date-text">${s.weekdaysShort[t]}, ${s.monthsShort[e]} ${i}</span>
        </div>
        `}
      </div>
    `;
}
function zo(i, t, e, s, n, o, r, a, l, d) {
  let h;
  return r.inline ? h = `
    <div class="datepicker-main">
      ${qo(t, e, r)}
      <div class="datepicker-view" tabindex="0">
        ${Go(
    i,
    e,
    s,
    n,
    o,
    r,
    a,
    l,
    d
  )}
      </div>
    </div>
  ` : h = `
      <div class="datepicker-main">
        ${qo(t, e, r)}
        <div class="datepicker-view" tabindex="0">
          ${Go(
    i,
    e,
    s,
    n,
    o,
    r,
    a,
    l,
    d
  )}
        </div>
        ${r_(r)}
      </div>
    `, h;
}
function Go(i, t, e, s, n, o, r, a, l) {
  let d;
  return o.view === "days" ? d = fi(i, e, o) : o.view === "months" ? d = _i(t, s, n, o, r) : d = mi(i, s, o, a, l), d;
}
function qo(i, t, e) {
  return `
    <div class="datepicker-date-controls">
      <button class="datepicker-view-change-button" aria-label="${e.switchToMultiYearViewLabel}">
        ${e.monthsFull[i]} ${t}
      </button>
      <div class="datepicker-arrow-controls">
        <button class="datepicker-previous-button" aria-label="${e.prevMonthLabel}"></button>
        <button class="datepicker-next-button" aria-label="${e.nextMonthLabel}"></button>
      </div>
    </div>
    `;
}
function r_(i) {
  const t = `<button class="datepicker-footer-btn datepicker-ok-btn" aria-label="${i.okBtnLabel}">${i.okBtnText}</button>`, e = `<button class="datepicker-footer-btn datepicker-cancel-btn" aria-label="${i.cancelBtnLabel}">${i.cancelBtnText}</button>`, s = `<button class="datepicker-footer-btn datepicker-clear-btn" aria-label="${i.clearBtnLabel}">${i.clearBtnText}</button>`;
  return `
        <div class="datepicker-footer">
          ${i.removeClearBtn ? "" : s}
          ${i.removeCancelBtn ? "" : e}
          ${i.removeOkBtn ? "" : t}
        </div>
      `;
}
function fi(i, t, e) {
  const s = a_(i, t, e), o = `
      <tr>
        ${e.weekdaysNarrow.map((a, l) => `<th class="datepicker-day-heading" scope="col" aria-label="${e.weekdaysFull[l]}">${a}</th>`).join("")}
      </tr>
    `, r = s.map((a) => `
        <tr>
          ${a.map((l) => `
              <td
              class="datepicker-cell datepicker-small-cell datepicker-day-cell
              ${l.currentMonth ? "" : "disabled"} ${l.disabled ? "disabled" : ""}
              ${l.isToday && "current"} ${l.isSelected && "selected"}"
              data-mdb-date="${R(l.date)}-${F(l.date)}-${U(l.date)}"
              aria-label="${l.date}"
              aria-selected="${l.isSelected}">
                <div
                  class="datepicker-cell-content datepicker-small-cell-content"
                  style="${l.currentMonth ? "display: block" : "display: none"}">
                  ${l.dayNumber}
                  </div>
              </td>
            `).join("")}
        </tr>
      `).join("");
  return `
      <table class="datepicker-table">
        <thead>
          ${o}
        </thead>
        <tbody class="datepicker-table-body">
         ${r}
        </tbody>
      </table>
    `;
}
function a_(i, t, e) {
  const s = [], n = F(i), o = F(Q(i, -1)), r = F(Q(i, 1)), a = R(i), l = Xf(a, n, e), d = $s(i), h = $s(Q(i, -1)), f = 7;
  let m = 1, _ = !1;
  for (let g = 1; g < f; g++) {
    const b = [];
    if (g === 1) {
      const y = h - l + 1;
      for (let N = y; N <= h; N++) {
        const E = _t(a, o, N);
        b.push({
          date: E,
          currentMonth: _,
          isSelected: t && Rt(E, t),
          isToday: Rt(E, se()),
          dayNumber: U(E),
          disabled: Se(
            E,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        });
      }
      _ = !0;
      const O = f - b.length;
      for (let N = 0; N < O; N++) {
        const E = _t(a, n, m);
        b.push({
          date: E,
          currentMonth: _,
          isSelected: t && Rt(E, t),
          isToday: Rt(E, se()),
          dayNumber: U(E),
          disabled: Se(
            E,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), m++;
      }
    } else
      for (let y = 1; y < 8; y++) {
        m > d && (m = 1, _ = !1);
        const O = _t(a, _ ? n : r, m);
        b.push({
          date: O,
          currentMonth: _,
          isSelected: t && Rt(O, t),
          isToday: Rt(O, se()),
          dayNumber: U(O),
          disabled: Se(
            O,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), m++;
      }
    s.push(b);
  }
  return s;
}
function _i(i, t, e, s, n) {
  const o = l_(s, n), r = F(se()), a = R(se());
  return `
      <table class="datepicker-table">
        <tbody class="datepicker-table-body">
         ${`
      ${o.map((d) => `
          <tr>
            ${d.map((h) => {
    const f = s.monthsShort.indexOf(h);
    return `
                <td class="datepicker-cell datepicker-large-cell datepicker-month-cell ${Ra(
      f,
      i,
      s.min,
      s.max,
      s.disablePast,
      s.disableFuture
    ) ? "disabled" : ""} ${f === e && i === t ? "selected" : ""} ${f === r && i === a ? "current" : ""}" data-mdb-month="${f}" data-mdb-year="${i}" aria-label="${h}, ${i}">
                  <div class="datepicker-cell-content datepicker-large-cell-content">${h}</div>
                </td>
              `;
  }).join("")}
          </tr>
        `).join("")}
    `}
        </tbody>
      </table>
    `;
}
function l_(i, t) {
  const e = [];
  let s = [];
  for (let n = 0; n < i.monthsShort.length; n++)
    if (s.push(i.monthsShort[n]), s.length === t) {
      const o = s;
      e.push(o), s = [];
    }
  return e;
}
function mi(i, t, e, s, n) {
  const o = c_(i, s, n), r = R(se());
  return `
      <table class="datepicker-table">
        <tbody class="datepicker-table-body">
        ${`
    ${o.map((l) => `
        <tr>
          ${l.map((d) => `
              <td class="datepicker-cell datepicker-large-cell datepicker-year-cell ${Ms(
    d,
    e.min,
    e.max,
    e.disablePast,
    e.disableFuture
  ) ? "disabled" : ""} ${d === t ? "selected" : ""} ${d === r ? "current" : ""}" aria-label="${d}" data-mdb-year="${d}">
                <div class="datepicker-cell-content datepicker-large-cell-content">${d}</div>
              </td>
            `).join("")}
        </tr>
      `).join("")}
  `}
        </tbody>
      </table>
    `;
}
function c_(i, t, e) {
  const s = [], n = R(i), o = pi(i, t), r = n - o;
  let a = [];
  for (let l = 0; l < t; l++)
    if (a.push(r + l), a.length === e) {
      const d = a;
      s.push(d), a = [];
    }
  return s;
}
function d_(i) {
  return `
    <button id="${i}" type="button" class="datepicker-toggle-button" data-mdb-toggle="datepicker">
      <i class="far fa-calendar datepicker-toggle-icon"></i>
    </button>
  `;
}
const lt = 24, ii = 4, si = 4, Ls = "datepicker", Ha = `mdb.${Ls}`, h_ = ".data-api", ki = `.${Ha}`, u_ = `close${ki}`, p_ = `open${ki}`, f_ = `valueChanged${ki}`, ni = `click${ki}${h_}`, __ = "fade-in", m_ = "fade-out", g_ = "fade-in", b_ = "fade-out", E_ = "form-icon-trailing", oi = '[data-mdb-toggle="datepicker"]', v_ = ".datepicker-modal-container", T_ = ".datepicker-dropdown-container", C_ = ".datepicker-view-change-button", A_ = ".datepicker-previous-button", y_ = ".datepicker-next-button", O_ = ".datepicker-ok-btn", S_ = ".datepicker-cancel-btn", w_ = ".datepicker-clear-btn", N_ = ".datepicker-view", D_ = {
  title: "Select date",
  container: "body",
  disablePast: !1,
  disableFuture: !1,
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  weekdaysFull: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Switch to year list",
  switchToDayViewLabel: "Switch to day list",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  min: null,
  max: null,
  filter: null,
  inline: !1,
  toggleButton: !0,
  disableToggleButton: !1,
  disableInput: !1,
  animations: !0,
  confirmDateOnSelect: !1,
  removeOkBtn: !1,
  removeCancelBtn: !1,
  removeClearBtn: !1,
  headerTemplate: null,
  headerTemplateModifier: null
}, $_ = {
  title: "string",
  container: "string",
  disablePast: "boolean",
  disableFuture: "boolean",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  switchToMultiYearViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  min: "(null|date|string)",
  max: "(null|date|string)",
  filter: "(null|function)",
  inline: "boolean",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean",
  animations: "boolean",
  confirmDateOnSelect: "boolean",
  removeOkBtn: "boolean",
  removeCancelBtn: "boolean",
  removeClearBtn: "boolean",
  headerTemplate: "(null|string)",
  headerTemplateModifier: "(null|function)"
};
class Ba extends me {
  constructor(t, e) {
    super(t), this._input = p.findOne("input", this._element), this._options = this._getConfig(e), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = this._element.id ? `datepicker-toggle-${this._element.id}` : Vt("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new Ne(), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true"), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  // Getters
  static get NAME() {
    return Ls;
  }
  get container() {
    return p.findOne(`${v_}-${this._toggleButtonId}`) || p.findOne(`${T_}-${this._toggleButtonId}`);
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let t;
    return this._view === "days" && (t = this._getActiveDayCell()), this._view === "months" && (t = this._getActiveMonthCell()), this._view === "years" && (t = this._getActiveYearCell()), t;
  }
  get activeDay() {
    return U(this._activeDate);
  }
  get activeMonth() {
    return F(this._activeDate);
  }
  get activeYear() {
    return R(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - pi(this._activeDate, lt);
  }
  get lastYearInView() {
    return this.firstYearInView + lt - 1;
  }
  get viewChangeButton() {
    return p.findOne(C_, this.container);
  }
  get previousButton() {
    return p.findOne(A_, this.container);
  }
  get nextButton() {
    return p.findOne(y_, this.container);
  }
  get okButton() {
    return p.findOne(O_, this.container);
  }
  get cancelButton() {
    return p.findOne(S_, this.container);
  }
  get clearButton() {
    return p.findOne(w_, this.container);
  }
  get datesContainer() {
    return p.findOne(N_, this.container);
  }
  get toggleButton() {
    return p.findOne(".datepicker-toggle-button", this._element);
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    if (t = {
      ...D_,
      ...e,
      ...t
    }, De(Ls, t, $_), t.max && typeof t.max == "string" && (t.max = new Date(t.max)), t.min && typeof t.min == "string" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {
      const s = this._getNewDaysOrderArray(t);
      t.weekdaysNarrow = s;
    }
    return t;
  }
  _getContainer() {
    return p.findOne(this._options.container);
  }
  _getNewDaysOrderArray(t) {
    const e = t.startDay, s = t.weekdaysNarrow;
    return s.slice(e).concat(s.slice(0, e));
  }
  _init() {
    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const t = d_(this._toggleButtonId);
    this._element.insertAdjacentHTML("beforeend", t), c.addClass(this._input, E_);
  }
  open() {
    if (this._input.readOnly || this._input.disabled)
      return;
    const t = u.trigger(this._element, p_);
    if (this._isOpen || t.defaultPrevented)
      return;
    this._setInitialDate();
    const e = n_(), s = s_(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      si,
      lt,
      ii,
      this._toggleButtonId
    );
    this._options.inline ? this._openDropdown(s) : (this._openModal(e, s), this._scrollBar.hide()), this._animations && (c.addClass(this.container, "animation"), c.addClass(this.container, g_), this.container.style.animationDuration = "300ms", c.addClass(e, "animation"), c.addClass(e, __), e.style.animationDuration = "150ms"), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(t) {
    this._popper = _e(this._input, t, {
      placement: "bottom-start"
    }), this._getContainer().appendChild(t);
  }
  _openModal(t, e) {
    const s = this._getContainer();
    s.appendChild(t), s.appendChild(e);
  }
  _setFocusTrap(t) {
    this._focusTrap = new Ia(t, {
      event: "keydown",
      condition: (e) => e.key === "Tab"
    }), this._focusTrap.trap();
  }
  _listenToUserInput() {
    u.on(this._input, "input", (t) => {
      this._handleUserInput(t.target.value);
    });
  }
  _listenToToggleClick() {
    u.on(this._element, ni, oi, (t) => {
      t.preventDefault(), this.open();
    });
  }
  _listenToToggleKeydown() {
    u.on(this._element, "keydown", oi, (t) => {
      t.keyCode === vt && !this._isOpen && this.open();
    });
  }
  _listenToDateSelection() {
    u.on(this.datesContainer, "click", (t) => {
      this._handleDateSelection(t);
    });
  }
  _handleDateSelection(t) {
    const e = t.target.nodeName === "DIV" ? t.target.parentNode.dataset : t.target.dataset, s = t.target.nodeName === "DIV" ? t.target.parentNode : t.target;
    if (e.mdbDate && this._pickDay(e.mdbDate, s), e.mdbMonth && e.mdbYear) {
      const n = parseInt(e.mdbMonth, 10), o = parseInt(e.mdbYear, 10);
      this._pickMonth(n, o);
    }
    if (e.mdbYear && !e.mdbMonth) {
      const n = parseInt(e.mdbYear, 10);
      this._pickYear(n);
    }
    this._options.inline || this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _updateHeaderDate(t, e, s) {
    const n = p.findOne(".datepicker-date-text", this.container), o = F(t), r = U(t), a = ui(t), l = p.findOne(".datepicker-header", this.container);
    if (this._options.headerTemplate && l) {
      l.innerHTML = Va(
        r,
        a,
        o,
        t,
        this._options
      );
      return;
    }
    n.innerHTML = `${s[a]}, ${e[o]} ${r}`;
  }
  _addControlsListeners() {
    u.on(this.nextButton, "click", () => {
      this._view === "days" ? this.nextMonth() : this._view === "years" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();
    }), u.on(this.previousButton, "click", () => {
      this._view === "days" ? this.previousMonth() : this._view === "years" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();
    }), u.on(this.viewChangeButton, "click", () => {
      this._view === "days" ? this._changeView("years") : (this._view === "years" || this._view === "months") && this._changeView("days");
    }), this._options.inline || this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    u.on(this.okButton, "click", () => this.handleOk()), u.on(this.cancelButton, "click", () => this.handleCancel()), u.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    u.on(document, ni, (t) => {
      const e = t.target === this.container, s = this.container && this.container.contains(t.target);
      !e && !s && this.close();
    });
  }
  _listenToEscapeClick() {
    u.on(document, "keydown", (t) => {
      t.keyCode === qs && this._isOpen && this.close();
    });
  }
  _listenToKeyboardNavigation() {
    u.on(this.datesContainer, "keydown", (t) => {
      this._handleKeydown(t);
    });
  }
  _listenToDatesContainerFocus() {
    u.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    u.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(t) {
    this._view === "days" && this._handleDaysViewKeydown(t), this._view === "months" && this._handleMonthsViewKeydown(t), this._view === "years" && this._handleYearsViewKeydown(t);
  }
  _handleDaysViewKeydown(t) {
    const e = this._activeDate, s = this.activeCell;
    switch (t.keyCode) {
      case di:
        this._activeDate = Xt(this._activeDate, Kt ? 1 : -1);
        break;
      case hi:
        this._activeDate = Xt(this._activeDate, Kt ? -1 : 1);
        break;
      case ot:
        this._activeDate = Xt(this._activeDate, -7);
        break;
      case Z:
        this._activeDate = Xt(this._activeDate, 7);
        break;
      case ye:
        this._activeDate = Xt(this._activeDate, 1 - U(this._activeDate));
        break;
      case Oe:
        this._activeDate = Xt(
          this._activeDate,
          $s(this._activeDate) - U(this._activeDate)
        );
        break;
      case ls:
        this._activeDate = Q(this._activeDate, -1);
        break;
      case cs:
        this._activeDate = Q(this._activeDate, 1);
        break;
      case vt:
      case ds:
        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();
        return;
      default:
        return;
    }
    we(
      e,
      this._activeDate,
      this._view,
      lt,
      this._options.min,
      this._options.max
    ) || this._changeView("days"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(t) {
    t && c.addClass(t, "focused");
  }
  _removeHighlightFromCell(t) {
    t && t.classList.remove("focused");
  }
  _getActiveDayCell() {
    const t = p.find("td", this.datesContainer);
    return Array.from(t).find((s) => {
      const n = Uo(s.dataset.mdbDate);
      return Rt(n, this._activeDate);
    });
  }
  _handleMonthsViewKeydown(t) {
    const e = this._activeDate, s = this.activeCell;
    switch (t.keyCode) {
      case di:
        this._activeDate = Q(this._activeDate, Kt ? 1 : -1);
        break;
      case hi:
        this._activeDate = Q(this._activeDate, Kt ? -1 : 1);
        break;
      case ot:
        this._activeDate = Q(this._activeDate, -4);
        break;
      case Z:
        this._activeDate = Q(this._activeDate, 4);
        break;
      case ye:
        this._activeDate = Q(this._activeDate, -this.activeMonth);
        break;
      case Oe:
        this._activeDate = Q(this._activeDate, 11 - this.activeMonth);
        break;
      case ls:
        this._activeDate = X(this._activeDate, -1);
        break;
      case cs:
        this._activeDate = X(this._activeDate, 1);
        break;
      case vt:
      case ds:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    we(
      e,
      this._activeDate,
      this._view,
      lt,
      this._options.min,
      this._options.max
    ) || this._changeView("months"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveMonthCell() {
    const t = p.find("td", this.datesContainer);
    return Array.from(t).find((s) => {
      const n = parseInt(s.dataset.mdbYear, 10), o = parseInt(s.dataset.mdbMonth, 10);
      return n === this.activeYear && o === this.activeMonth;
    });
  }
  _handleYearsViewKeydown(t) {
    const e = this._activeDate, s = this.activeCell, n = 4, o = 24;
    switch (t.keyCode) {
      case di:
        this._activeDate = X(this._activeDate, Kt ? 1 : -1);
        break;
      case hi:
        this._activeDate = X(this._activeDate, Kt ? -1 : 1);
        break;
      case ot:
        this._activeDate = X(this._activeDate, -n);
        break;
      case Z:
        this._activeDate = X(this._activeDate, n);
        break;
      case ye:
        this._activeDate = X(
          this._activeDate,
          -pi(this._activeDate, o)
        );
        break;
      case Oe:
        this._activeDate = X(
          this._activeDate,
          o - pi(this._activeDate, o) - 1
        );
        break;
      case ls:
        this._activeDate = X(this._activeDate, -o);
        break;
      case cs:
        this._activeDate = X(this._activeDate, o);
        break;
      case vt:
      case ds:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    we(
      e,
      this._activeDate,
      this._view,
      lt,
      this._options.min,
      this._options.max
    ) || this._changeView("years"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveYearCell() {
    const t = p.find("td", this.datesContainer);
    return Array.from(t).find((s) => parseInt(s.dataset.mdbYear, 10) === this.activeYear);
  }
  _setInitialDate() {
    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();
  }
  close() {
    const t = u.trigger(this._element, u_);
    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && (c.addClass(this.container, "animation"), c.addClass(this.container, b_)), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());
  }
  _closeDropdown() {
    const t = p.findOne(".datepicker-dropdown-container"), e = this._getContainer();
    this._animations ? t.addEventListener("animationend", () => {
      t && e.removeChild(t), this._popper && this._popper.destroy();
    }) : (t && e.removeChild(t), this._popper && this._popper.destroy()), this._removeFocusTrap();
  }
  _closeModal() {
    const t = p.findOne(".datepicker-backdrop"), e = p.findOne(".datepicker-modal-container");
    !e || !t || (this._animations && (c.addClass(t, "animation"), c.addClass(t, m_)), this._animations ? t.addEventListener("animationend", () => {
      this._removePicker(t, e), this._scrollBar.reset();
    }) : (this._removePicker(t, e), this._scrollBar.reset()));
  }
  _removePicker(t, e) {
    const s = this._getContainer();
    s.removeChild(t), s.removeChild(e);
  }
  _removeFocusTrap() {
    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);
  }
  _removeDatepickerListeners() {
    u.off(this.nextButton, "click"), u.off(this.previousButton, "click"), u.off(this.viewChangeButton, "click"), u.off(this.okButton, "click"), u.off(this.cancelButton, "click"), u.off(this.clearButton, "click"), u.off(this.datesContainer, "click"), u.off(this.datesContainer, "keydown"), u.off(this.datesContainer, "focus"), u.off(this.datesContainer, "blur"), u.off(document, ni);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndToggleListeners();
    const t = p.findOne(`#${this._toggleButtonId}`);
    t && this._element.removeChild(t), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  _removeInputAndToggleListeners() {
    u.off(this._input, "input"), u.off(this._element, ni, oi), u.off(this._element, "keydown", oi);
  }
  handleOk() {
    this._confirmSelection(this._headerDate), this.close();
  }
  _selectDate(t, e = this.activeCell) {
    const { min: s, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;
    Se(t, s, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = R(t), this._selectedMonth = F(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));
  }
  _selectYear(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months");
  }
  _selectMonth(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days");
  }
  _removeSelectedStyles(t) {
    t && t.classList.remove("selected");
  }
  _addSelectedStyles(t) {
    t && c.addClass(t, "selected");
  }
  _confirmSelection(t) {
    if (t) {
      const e = this.formatDate(t);
      this._input.value = e, c.addClass(this._input, "active"), u.trigger(this._element, f_, { date: t });
    }
  }
  handleCancel() {
    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();
  }
  handleClear() {
    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._input.classList.remove("active"), this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _removeCurrentSelectionStyles() {
    const t = p.findOne(".selected", this.container);
    t && t.classList.remove("selected");
  }
  _removeCurrentFocusStyles() {
    const t = p.findOne(".focused", this.container);
    t && t.classList.remove("focused");
  }
  formatDate(t) {
    const e = U(t), s = this._addLeadingZero(U(t)), n = this._options.weekdaysShort[ui(t)], o = this._options.weekdaysFull[ui(t)], r = F(t) + 1, a = this._addLeadingZero(F(t) + 1), l = this._options.monthsShort[F(t)], d = this._options.monthsFull[F(t)], h = R(t).toString().length === 2 ? R(t) : R(t).toString().slice(2, 4), f = R(t), m = this._options.format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
    let _ = "";
    return m.forEach((g) => {
      switch (g) {
        case "dddd":
          g = g.replace(g, o);
          break;
        case "ddd":
          g = g.replace(g, n);
          break;
        case "dd":
          g = g.replace(g, s);
          break;
        case "d":
          g = g.replace(g, e);
          break;
        case "mmmm":
          g = g.replace(g, d);
          break;
        case "mmm":
          g = g.replace(g, l);
          break;
        case "mm":
          g = g.replace(g, a);
          break;
        case "m":
          g = g.replace(g, r);
          break;
        case "yyyy":
          g = g.replace(g, f);
          break;
        case "yy":
          g = g.replace(g, h);
          break;
      }
      _ += g;
    }), _;
  }
  _addLeadingZero(t) {
    return parseInt(t, 10) < 10 ? `0${t}` : t;
  }
  _pickDay(t, e) {
    const s = Uo(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;
    Se(s, n, o, r, a, l) || (this._activeDate = s, this._selectDate(s, e));
  }
  _pickYear(t) {
    const { min: e, max: s, disablePast: n, disableFuture: o } = this._options;
    if (Ms(t, e, s, n, o))
      return;
    const r = _t(t, this.activeMonth, this.activeDay);
    this._activeDate = r, this._selectedDate = r, this._selectYear(t);
  }
  _pickMonth(t, e) {
    const { min: s, max: n, disablePast: o, disableFuture: r } = this._options;
    if (Ra(t, e, s, n, o, r) || Ms(e, s, n, o, r))
      return;
    const a = _t(e, t, this.activeDay);
    this._activeDate = a, this._selectMonth(t);
  }
  nextMonth() {
    const t = Q(this._activeDate, 1), e = fi(t, this._headerDate, this._options);
    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.datesContainer.innerHTML = e;
  }
  previousMonth() {
    const t = Q(this._activeDate, -1);
    this._activeDate = t;
    const e = fi(t, this._headerDate, this._options);
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.datesContainer.innerHTML = e;
  }
  nextYear() {
    const t = X(this._activeDate, 1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`;
    const e = _i(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      si
    );
    this.datesContainer.innerHTML = e;
  }
  previousYear() {
    const t = X(this._activeDate, -1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`;
    const e = _i(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      si
    );
    this.datesContainer.innerHTML = e;
  }
  nextYears() {
    const t = X(this._activeDate, 24);
    this._activeDate = t;
    const e = mi(
      t,
      this._selectedYear,
      this._options,
      lt,
      ii
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.datesContainer.innerHTML = e;
  }
  previousYears() {
    const t = X(this._activeDate, -24);
    this._activeDate = t;
    const e = mi(
      t,
      this._selectedYear,
      this._options,
      lt,
      ii
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.datesContainer.innerHTML = e;
  }
  _asyncChangeView(t) {
    setTimeout(() => {
      this._changeView(t);
    }, 0);
  }
  _changeView(t) {
    this._view = t, this.datesContainer.blur(), t === "days" && (this.datesContainer.innerHTML = fi(
      this._activeDate,
      this._headerDate,
      this._options
    )), t === "months" && (this.datesContainer.innerHTML = _i(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      si
    )), t === "years" && (this.datesContainer.innerHTML = mi(
      this._activeDate,
      this._selectedYear,
      this._options,
      lt,
      ii
    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();
  }
  _updateViewControlsAndAttributes(t) {
    t === "days" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.setAttribute("aria-label", this._options.switchToMultiYearViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevMonthLabel), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), t === "months" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.setAttribute("aria-label", this._options.switchToDayViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevYearLabel), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), t === "years" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.setAttribute("aria-label", this._options.switchToDayViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevMultiYearLabel), this.nextButton.setAttribute("aria-label", this._options.nextMultiYearLabel));
  }
  _updateControlsDisabledState() {
    e_(
      this._options.disableFuture,
      this._activeDate,
      this._view,
      lt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, i_(
      this._options.disablePast,
      this._activeDate,
      this._view,
      lt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;
  }
  _handleUserInput(t) {
    const e = this._getDelimeters(this._options.format), s = this._parseDate(t, this._options.format, e);
    Zf(s) ? (this._activeDate = s, this._selectedDate = s, this._selectedYear = R(s), this._selectedMonth = F(s), this._headerDate = s) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);
  }
  _getDelimeters(t) {
    return t.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(t, e, s) {
    let n;
    s[0] !== s[1] ? n = s[0] + s[1] : n = s[0];
    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf("mmm") !== -1, d = [];
    for (let b = 0; b < a.length; b++)
      a[b].indexOf("yy") !== -1 && (d[0] = { value: r[b], format: a[b] }), a[b].indexOf("m") !== -1 && (d[1] = { value: r[b], format: a[b] }), a[b].indexOf("d") !== -1 && a[b].length <= 2 && (d[2] = { value: r[b], format: a[b] });
    let h;
    e.indexOf("mmmm") !== -1 ? h = this._options.monthsFull : h = this._options.monthsShort;
    const f = Number(d[0].value), m = l ? this.getMonthNumberByMonthName(d[1].value, h) : Number(d[1].value) - 1, _ = Number(d[2].value);
    return _t(f, m, _);
  }
  getMonthNumberByMonthName(t, e) {
    return e.findIndex((s) => s === t);
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = ct.getData(this, Ha);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Ba(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const Xo = ".form-check-input", ri = "selected", Qo = "active";
class Zo {
  constructor(t, e, s, n, o, r, a, l, d, h, f) {
    this.id = t, this.nativeOption = e, this.multiple = s, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = d, this.groupId = h, this.icon = f, this.node = null, this.active = !1;
  }
  select() {
    this.multiple ? this._selectMultiple() : this._selectSingle();
  }
  _selectSingle() {
    this.selected || (c.addClass(this.node, ri), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));
  }
  _selectMultiple() {
    if (!this.selected) {
      const t = p.findOne(Xo, this.node);
      t.checked = !0, c.addClass(this.node, ri), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);
    }
  }
  deselect() {
    this.multiple ? this._deselectMultiple() : this._deselectSingle();
  }
  _deselectSingle() {
    this.selected && (c.removeClass(this.node, ri), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));
  }
  _deselectMultiple() {
    if (this.selected) {
      const t = p.findOne(Xo, this.node);
      t.checked = !1, c.removeClass(this.node, ri), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);
    }
  }
  setNode(t) {
    this.node = t;
  }
  setActiveStyles() {
    !this.active && !this.multiple && (this.active = !0, c.addClass(this.node, Qo));
  }
  removeActiveStyles() {
    this.active && (this.active = !1, c.removeClass(this.node, Qo));
  }
}
class M_ {
  constructor(t = !1) {
    this._multiple = t, this._selections = [];
  }
  select(t) {
    this._multiple ? this._selections.push(t) : this._selections = [t];
  }
  deselect(t) {
    if (this._multiple) {
      const e = this._selections.findIndex((s) => t === s);
      this._selections.splice(e, 1);
    } else
      this._selections = [];
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((t) => t.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((t) => t.value);
  }
}
function ks(i) {
  return i.filter((t) => !t.disabled).every((t) => t.selected);
}
const L_ = (i) => {
  i.code === "Tab" || i.code === "Esc" || i.preventDefault();
};
function k_(i, t, e) {
  const s = document.createElement("div");
  s.setAttribute("id", i), s.classList.add("select-wrapper");
  const n = P("div");
  c.addClass(n, "form-outline"), n.setAttribute("data-mdb-input-init", ""), t.formWhite && c.addClass(n, "form-white");
  const o = P("input"), r = t.filter ? "combobox" : "listbox", a = t.multiple ? "true" : "false", l = t.disabled ? "true" : "false";
  c.addClass(o, "form-control"), c.addClass(o, "select-input"), t.size === "sm" && c.addClass(o, "form-control-sm"), t.size === "lg" && c.addClass(o, "form-control-lg"), o.setAttribute("type", "text"), o.setAttribute("role", r), o.setAttribute("aria-multiselectable", a), o.setAttribute("aria-disabled", l), o.setAttribute("aria-haspopup", "true"), o.setAttribute("aria-expanded", !1), t.tabIndex && o.setAttribute("tabIndex", t.tabIndex), t.disabled && o.setAttribute("disabled", ""), t.placeholder !== "" && o.setAttribute("placeholder", t.placeholder), t.validation ? (c.addStyle(o, { "pointer-events": "none", "caret-color": "transparent" }), c.addStyle(n, { cursor: "pointer" })) : o.setAttribute("readonly", "true"), t.validation && (o.setAttribute("required", "true"), o.setAttribute("aria-required", "true"), o.addEventListener("keydown", L_));
  const d = P("div");
  c.addClass(d, "valid-feedback");
  const h = document.createTextNode(`${t.validFeedback}`);
  d.appendChild(h);
  const f = P("div");
  c.addClass(f, "invalid-feedback");
  const m = document.createTextNode(`${t.invalidFeedback}`);
  f.appendChild(m);
  const _ = P("span");
  c.addClass(_, "select-clear-btn");
  const g = document.createTextNode("✕");
  _.appendChild(g), _.setAttribute("tabindex", "0");
  const b = P("span");
  return c.addClass(b, "select-arrow"), n.appendChild(o), e && n.appendChild(e), t.validation && (n.appendChild(d), n.appendChild(f)), t.clearButton && n.appendChild(_), n.appendChild(b), s.appendChild(n), s;
}
function Jo(i, t, e, s, n, o, r) {
  const a = document.createElement("div");
  a.classList.add("select-dropdown-container"), a.setAttribute("id", `${i}`), a.style.width = `${e}px`;
  const l = document.createElement("div");
  l.setAttribute("tabindex", 0), l.classList.add("select-dropdown");
  const d = P("div");
  c.addClass(d, "select-options-wrapper"), d.style.maxHeight = `${s}px`;
  const h = Fa(o, n, t);
  return d.appendChild(h), t.filter && l.appendChild(I_(t.searchPlaceholder)), l.appendChild(d), r && l.appendChild(r), a.appendChild(l), a;
}
function Fa(i, t, e) {
  const s = P("div");
  c.addClass(s, "select-options-list");
  let n;
  return e.multiple ? n = P_(i, t, e) : n = x_(i, e), n.forEach((o) => {
    s.appendChild(o);
  }), s;
}
function I_(i) {
  const t = P("div");
  c.addClass(t, "input-group");
  const e = P("input");
  return c.addClass(e, "form-control"), c.addClass(e, "select-filter-input"), e.placeholder = i, e.setAttribute("role", "searchbox"), e.setAttribute("type", "text"), t.appendChild(e), t;
}
function x_(i, t) {
  return Wa(i, t);
}
function P_(i, t, e) {
  let s = null;
  e.selectAll && (s = R_(t, i, e));
  const n = Wa(i, e);
  return s ? [s, ...n] : n;
}
function Wa(i, t) {
  const e = [];
  return i.forEach((s) => {
    if (s.hasOwnProperty("options")) {
      const o = F_(s, t);
      e.push(o);
    } else
      e.push(Ya(s, t));
  }), e;
}
function R_(i, t, e) {
  const s = ks(t), n = P("div");
  return c.addClass(n, "select-option"), c.addClass(n, "select-all-option"), c.addStyle(n, { height: `${e.optionHeight}px` }), n.setAttribute("role", "option"), n.setAttribute("aria-selected", s), s && c.addClass(n, "selected"), n.appendChild(ja(i, e)), i.setNode(n), n;
}
function Ya(i, t) {
  if (i.node)
    return i.node;
  const e = P("div");
  return c.addClass(e, "select-option"), c.addStyle(e, { height: `${t.optionHeight}px` }), c.setDataAttribute(e, "id", i.id), e.setAttribute("role", "option"), e.setAttribute("aria-selected", i.selected), e.setAttribute("aria-disabled", i.disabled), i.selected && c.addClass(e, "selected"), i.disabled && c.addClass(e, "disabled"), i.hidden && c.addClass(e, "d-none"), e.appendChild(ja(i, t)), i.icon && e.appendChild(B_(i)), i.setNode(e), e;
}
function ja(i, t) {
  const e = P("span");
  c.addClass(e, "select-option-text");
  const s = document.createTextNode(i.label);
  return t.multiple && e.appendChild(H_(i)), e.appendChild(s), (i.secondaryText || typeof i.secondaryText == "number") && e.appendChild(V_(i.secondaryText)), e;
}
function V_(i) {
  const t = P("span");
  c.addClass(t, "select-option-secondary-text");
  const e = document.createTextNode(i);
  return t.appendChild(e), t;
}
function H_(i) {
  const t = P("input");
  t.setAttribute("type", "checkbox"), c.addClass(t, "form-check-input");
  const e = P("label");
  return i.selected && t.setAttribute("checked", !0), i.disabled && t.setAttribute("disabled", !0), t.appendChild(e), t;
}
function B_(i) {
  const t = P("span");
  c.addClass(t, "select-option-icon-container");
  const e = P("img");
  return c.addClass(e, "select-option-icon"), c.addClass(e, "rounded-circle"), e.src = i.icon, t.appendChild(e), t;
}
function F_(i, t) {
  const e = P("div");
  c.addClass(e, "select-option-group"), e.setAttribute("role", "group"), e.setAttribute("id", i.id), i.hidden && c.addClass(e, "d-none");
  const s = P("label");
  return c.addClass(s, "select-option-group-label"), c.addStyle(s, { height: `${t.optionHeight}px` }), s.setAttribute("for", i.id), s.textContent = i.label, e.appendChild(s), i.options.forEach((n) => {
    e.appendChild(Ya(n, t));
  }), e;
}
function W_(i) {
  const t = P("div");
  return t.textContent = i, c.addClass(t, "form-label"), c.addClass(t, "select-fake-value"), t;
}
const Y_ = {
  autoSelect: !1,
  container: "body",
  clearButton: !1,
  disabled: !1,
  displayedLabels: 5,
  formWhite: !1,
  multiple: !1,
  optionsSelectedLabel: "options selected",
  optionHeight: 38,
  selectAll: !0,
  selectAllLabel: "Select all",
  searchPlaceholder: "Search...",
  size: "default",
  visibleOptions: 5,
  filter: !1,
  filterDebounce: 300,
  noResultText: "No results",
  validation: !1,
  validFeedback: "Valid",
  invalidFeedback: "Invalid",
  placeholder: "",
  filterFn: null
}, j_ = {
  autoSelect: "boolean",
  container: "string",
  clearButton: "boolean",
  disabled: "boolean",
  displayedLabels: "number",
  formWhite: "boolean",
  multiple: "boolean",
  optionsSelectedLabel: "string",
  optionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  searchPlaceholder: "string",
  size: "string",
  visibleOptions: "number",
  filter: "boolean",
  filterDebounce: "number",
  noResultText: "string",
  validation: "boolean",
  validFeedback: "string",
  invalidFeedback: "string",
  placeholder: "",
  filterFn: "(function|null)"
}, tr = "select", Ka = "mdb.select", Yt = `.${Ka}`, K_ = `close${Yt}`, U_ = `open${Yt}`, er = `optionSelected${Yt}`, ir = `optionDeselected${Yt}`, z_ = `valueChanged${Yt}`, G_ = "change", q_ = `opened${Yt}`, X_ = `closed${Yt}`, Q_ = ".select-label", sr = ".select-input", Z_ = ".select-filter-input", J_ = ".select-dropdown", tm = ".select-options-wrapper", nr = ".select-options-list", em = ".select-option", im = ".select-clear-btn", sm = ".select-custom-content", nm = ".select-no-results", or = ".form-outline", om = "[data-mdb-toggle]", bs = "select-initialized", rr = "open", Et = "active", ar = "focused", rm = "select-option-group-label", am = "select-all-option", lm = 200;
class Ua extends me {
  constructor(t, e) {
    super(t), this._config = this._getConfig(e), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new M_(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = this._element.id ? `select-wrapper-${this._element.id}` : Vt("select-wrapper-"), this._dropdownContainerId = this._element.id ? `select-dropdown-container-${this._element.id}` : Vt("select-dropdown-container-"), this._selectAllId = this._element.id ? `select-all-${this._element.id}` : Vt("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.optionHeight * this._config.visibleOptions, this._popper = null, this._input = null, this._label = p.next(this._element, Q_)[0], this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = p.next(t, sm)[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), c.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), Y(this.constructor);
  }
  static get NAME() {
    return tr;
  }
  get filterInput() {
    return p.findOne(Z_, this._dropdownContainer);
  }
  get dropdown() {
    return p.findOne(J_, this._dropdownContainer);
  }
  get optionsList() {
    return p.findOne(nr, this._dropdownContainer);
  }
  get optionsWrapper() {
    return p.findOne(tm, this._dropdownContainer);
  }
  get clearButton() {
    return p.findOne(im, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...Y_,
      ...e,
      ...t
    }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), De(tr, t, j_), t;
  }
  _getOptionsToRender(t) {
    const e = [];
    return t.childNodes.forEach((n) => {
      if (n.nodeName === "OPTGROUP") {
        const o = {
          id: n.id ? `group-${n.id}` : Vt("group-"),
          label: n.label,
          disabled: n.hasAttribute("disabled"),
          hidden: n.hasAttribute("hidden"),
          options: []
        };
        n.childNodes.forEach((a) => {
          a.nodeName === "OPTION" && o.options.push(this._createOptionObject(a, o));
        }), e.push(o);
      } else
        n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
    }), e;
  }
  _getPlainOptions(t) {
    if (!p.findOne("optgroup", this._element))
      return t;
    const s = [];
    return t.forEach((n) => {
      n.hasOwnProperty("options") ? n.options.forEach((r) => {
        s.push(r);
      }) : s.push(n);
    }), s;
  }
  _createOptionObject(t, e = {}) {
    const s = t.id ? `option-${t.id}` : Vt("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute("selected"), a = t.hasAttribute("disabled") || o, l = t.hasAttribute("hidden") || e && e.hidden, d = this.multiple, h = t.value, f = t.label, m = c.getDataAttribute(t, "secondaryText"), _ = c.getDataAttribute(t, "icon");
    return new Zo(
      s,
      t,
      d,
      h,
      f,
      r,
      a,
      l,
      m,
      n,
      _
    );
  }
  _getNavigationOptions() {
    const t = this.options.filter((e) => !e.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
  }
  _init() {
    this._renderMaterialWrapper(), this._wrapper = p.findOne(`#${this._wrapperId}`), this._input = p.findOne(sr, this._wrapper), this._element.getAttribute("autocomplete") === "off" && this._input.setAttribute("autocomplete", "off");
    const t = this._config.container;
    t === "body" ? this._container = document.body : this._container = p.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = Jo(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent
    ), this._setFirstActiveOption();
  }
  _renderMaterialWrapper() {
    const t = k_(this._wrapperId, this._config, this._label);
    this._element.parentNode.insertBefore(t, this._element), c.addClass(this._element, bs), t.appendChild(this._element);
  }
  _initOutlineInput() {
    const t = p.findOne(or, this._wrapper);
    new Gs(t).init();
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((t) => {
      t.selected && this._selectionModel.select(t);
    });
  }
  _listenToComponentKeydown() {
    u.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(t) {
    this._isOpen && !this._config.filter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode, s = e === qs || e === ot && t.altKey || e === So;
    if (e === So && this._config.autoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), s) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case Z:
        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case ot:
        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case ye:
        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Oe:
        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case vt:
        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _handleClosedKeydown(t) {
    const e = t.keyCode;
    if (e === vt && t.preventDefault(), (e === vt || e === Z && t.altKey || e === Z && this.multiple) && this.open(), this.multiple)
      switch (e) {
        case Z:
          this.open();
          break;
        case ot:
          this.open();
          break;
        default:
          return;
      }
    else
      switch (e) {
        case Z:
          if (t.altKey)
            return;
          this._setNextOptionActive(), this._handleSelection(this._activeOption);
          break;
        case ot:
          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
          break;
        case ye:
          this._setFirstOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Oe:
          this._setLastOptionActive(), this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    t.preventDefault();
  }
  _scrollToOption(t) {
    if (!t)
      return;
    let e;
    const s = this.options.filter((h) => !h.hidden);
    this.hasSelectAll ? e = s.indexOf(t) + 1 : e = s.indexOf(t);
    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.optionHeight, d = r.scrollTop;
    if (e > -1) {
      const h = o * l, f = h + l > d + a;
      h < d ? r.scrollTop = h : f ? r.scrollTop = h - a + l : r.scrollTop = d;
    }
  }
  _getNumberOfGroupsBeforeOption(t) {
    const e = this.options.filter((r) => !r.hidden), s = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
    let o = 0;
    for (let r = 0; r <= n; r++)
      e[r].groupId && s[o] && s[o].id && e[r].groupId === s[o].id && o++;
    return o;
  }
  _setNextOptionActive() {
    let t = this._activeOptionIndex + 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t += 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setPreviousOptionActive() {
    let t = this._activeOptionIndex - 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t -= 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setFirstOptionActive() {
    const e = this._getNavigationOptions();
    this._updateActiveOption(e[0], 0);
  }
  _setLastOptionActive() {
    const t = this._getNavigationOptions(), e = t.length - 1;
    this._updateActiveOption(t[e], e);
  }
  _updateActiveOption(t, e) {
    const s = this._activeOption;
    s && s.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
  }
  _listenToWrapperClick() {
    u.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    u.on(this.clearButton, "click", (t) => {
      t.preventDefault(), t.stopPropagation(), this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    u.on(this.clearButton, "keydown", (t) => {
      t.keyCode === vt && (this._handleClear(), t.preventDefault(), t.stopPropagation());
    });
  }
  _handleClear() {
    if (this.multiple)
      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
    else {
      const t = this._selectionModel.selection;
      this._selectionModel.clear(), t.deselect();
    }
    this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    u.on(this.optionsWrapper, "click", (t) => {
      if (t.target.classList.contains(rm))
        return;
      const s = t.target.nodeName === "DIV" ? t.target : p.closest(t.target, em);
      if (s.classList.contains(am)) {
        this._handleSelectAll();
        return;
      }
      const o = s.dataset.mdbId, r = this.options.find((a) => a.id === o);
      r && !r.disabled && this._handleSelection(r);
    });
  }
  _handleSelectAll() {
    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _selectAllOptions(t) {
    t.forEach((e) => {
      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
    });
  }
  _deselectAllOptions(t) {
    t.forEach((e) => {
      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
    });
  }
  _handleSelection(t) {
    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleAutoSelection(t) {
    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleSingleSelection(t) {
    this._singleOptionSelect(t), this.close(), this._input.focus();
  }
  _singleOptionSelect(t) {
    const e = this._selectionModel.selections[0];
    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute("selected", !1), u.trigger(this._element, ir, { value: e.value })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute("selected", !0), u.trigger(this._element, er, { value: t.value }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
  }
  _handleMultiSelection(t) {
    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute("selected", !1), u.trigger(this._element, ir, { value: t.value })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute("selected", !0), u.trigger(this._element, er, { value: t.value })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(t) {
    u.trigger(this._element, z_, { value: t });
  }
  _emitNativeChangeEvent() {
    u.trigger(this._element, G_);
  }
  _updateInputValue() {
    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let e;
    this.multiple && this._config.displayedLabels !== -1 && this._selectionModel.selections.length > this._config.displayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.optionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
  }
  _isSelectionValid(t) {
    return !(t && (t.disabled || t.value === ""));
  }
  _isLabelEmpty(t) {
    return !!(t && t.label === "");
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple)
      return;
    const t = this._selectionModel.selection.label;
    this._fakeValue = W_(t), p.findOne(or, this._wrapper).appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const t = c.hasClass(this._element, bs), e = this._input.value !== "";
    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? c.addClass(this._label, Et) : c.removeClass(this._label, Et));
  }
  _updateLabelPositionWhileClosing() {
    this._label && (this._input.value !== "" || this._isFakeValueActive ? c.addClass(this._label, Et) : c.removeClass(this._label, Et));
  }
  _updateFakeLabelPosition() {
    this._fakeValue && (this.hasSelection && (this._fakeValue.textContent = this.hasSelection.label), this._input.value === "" && this._fakeValue.innerHTML !== "" ? (this._isFakeValueActive = !0, c.addClass(this._fakeValue, Et)) : (this._isFakeValueActive = !1, c.removeClass(this._fakeValue, Et)));
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton)
      return;
    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? c.addStyle(this.clearButton, { display: "block" }) : c.addStyle(this.clearButton, { display: "none" });
  }
  _updateSelectAllState() {
    const t = this._selectAllOption.selected, e = ks(this.options);
    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
  }
  toggle() {
    this._isOpen ? this.close() : this.open();
  }
  open() {
    const t = this._config.disabled, e = u.trigger(this._element, U_);
    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.filter && (setTimeout(() => {
      this.filterInput.focus();
    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, u.trigger(this._element, q_), this._updateLabelPosition(), this._setInputActiveStyles());
  }
  _openDropdown() {
    this._popper = _e(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
      c.addClass(this.dropdown, rr);
    }, 0);
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    c.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _setFirstActiveOption() {
    const t = this._getNavigationOptions(), e = this._activeOption;
    e && e.removeActiveStyles();
    const s = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    s ? (this._activeOption = s, s.setActiveStyles(), this._activeOptionIndex = t.findIndex((n) => n === s)) : (this._activeOption = null, this._activeOptionIndex = -1);
  }
  _setInputActiveStyles() {
    c.addClass(this._input, ar);
  }
  _listenToWindowResize() {
    u.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (t) => {
      const e = t.target.value, s = this._config.filterDebounce;
      this._debounceFilter(e, s);
    });
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(t);
    }, e);
  }
  _filterOptions(t) {
    const e = [], s = this._config.filterFn;
    this._optionsToRender.forEach((r) => {
      const a = r.hasOwnProperty("options"), l = !a && r.label.toLowerCase().includes(t.toLowerCase()), d = {};
      a && (d.label = r.label, d.options = this._filter(t, r.options), d.options.length > 0 && e.push(d)), s && !a ? s(t, r) && e.push(r) : l && e.push(r);
    });
    const n = this._config.noResultText !== "", o = e.length !== 0;
    if (o)
      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
    else if (!o && n) {
      const r = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = r;
    }
  }
  _updateOptionsListTemplate(t) {
    const e = p.findOne(nr, this._dropdownContainer) || p.findOne(nm, this._dropdownContainer), s = Fa(
      t,
      this._selectAllOption,
      this._config
    );
    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(s);
  }
  _getNoResultTemplate() {
    return `<div class="select-no-results" style="height: ${this._config.optionHeight}px">${this._config.noResultText}</div>`;
  }
  _filter(t, e) {
    const s = this._config.filterFn;
    if (s)
      return e.filter((o) => s(t, o));
    const n = t.toLowerCase();
    return e.filter((o) => o.label.toLowerCase().includes(n));
  }
  _listenToDropdownKeydown() {
    u.on(this.dropdown, "keydown", this._handleOpenKeydown.bind(this));
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this), u.on(document, "click", this._outsideClick);
  }
  _handleOutSideClick(t) {
    const e = this._wrapper && this._wrapper.contains(t.target), s = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    let o;
    this._toggleButton || (this._elementToggle = p.find(om)), this._elementToggle && this._elementToggle.forEach((r) => {
      const a = c.getDataAttribute(r, "toggle");
      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
    }), !e && !s && !n && !o && this.close();
  }
  close() {
    const t = u.trigger(this._element, K_);
    !this._isOpen || t.defaultPrevented || (this._config.filter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), c.removeClass(this.dropdown, rr), setTimeout(() => {
      c.removeClass(this._input, ar), this._label && !this.hasSelection && (c.removeClass(this._label, Et), c.removeClass(this._input, Et)), this._updateLabelPositionWhileClosing();
    }, 0), setTimeout(() => {
      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, u.off(this.dropdown, "transitionend"), u.trigger(this._element, X_);
    }, lm));
  }
  _resetFilterState() {
    this.filterInput.value = "", this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    u.off(document, "click", this._outsideClick), this._config.filter && u.off(this.dropdown, "keydown"), u.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      this._wrapper && (this._updateSelections(), this._updateDisabledState());
    }), this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
    const t = this._config.filter && this.filterInput && this.filterInput.value;
    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = Jo(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent
    );
  }
  _updateDisabledState() {
    const t = p.findOne(sr, this._wrapper);
    this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", "")) : (this._config.disabled = !1, t.removeAttribute("disabled"));
  }
  _observeMutationObserver() {
    this._mutationObserver && this._mutationObserver.observe(this._element, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    });
  }
  _disconnectMutationObserver() {
    this._mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
  }
  _createSelectAllOption() {
    const t = this._selectAllId, e = null, s = !0, n = "select-all", o = this._config.selectAllLabel, r = ks(this.options), a = !1, l = !1, d = null, h = null, f = null;
    return new Zo(
      t,
      e,
      s,
      n,
      o,
      r,
      a,
      l,
      d,
      h,
      f
    );
  }
  dispose() {
    this._disconnectMutationObserver(), this._removeComponentEvents(), this._disconnectMutationObserver(), this._destroyMaterialSelect(), c.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  _removeComponentEvents() {
    u.off(this.input, "click"), u.off(this.wrapper, this._handleKeydown.bind(this)), u.off(this.clearButton, "click"), u.off(this.clearButton, "keydown"), u.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    this._isOpen && this.close(), this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const t = this._wrapper.parentNode, e = p.find("label", this._wrapper);
    t.appendChild(this._element), e.forEach((s) => {
      t.appendChild(s);
    }), e.forEach((s) => {
      c.removeClass(s, Et);
    }), c.removeClass(this._element, bs), this._customContent && t.appendChild(this._customContent), t.removeChild(this._wrapper);
  }
  setValue(t) {
    this.options.filter((s) => s.selected).forEach((s) => s.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((s) => {
      this._selectByValue(s);
    }) : this._selectByValue(t), this._updateSelections();
  }
  _selectByValue(t) {
    const e = this.options.find((s) => s.value === t);
    return e ? (e.nativeOption.selected = !0, !0) : !1;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = ct.getData(this, Ka);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Ua(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const cm = (i, t) => {
  const e = i;
  Wt(e, "close"), p.find(t).forEach((s) => e.getOrCreateInstance(s));
}, dm = (i, t) => {
  const e = i, s = `click.bs.${i.name}.data-api`;
  u.on(document, s, t, (n) => {
    n.preventDefault();
    const o = n.target.closest(t);
    e.getOrCreateInstance(o).toggle();
  }), p.find(t).forEach((n) => e.getOrCreateInstance(n));
}, hm = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = "[data-mdb-slide], [data-mdb-slide-to]", n = "carousel", o = i, r = `load.bs.${i.name}.data-api`, a = t;
  u.on(document, e, s, function(l) {
    const d = ne(this);
    if (!d || !d.classList.contains(n))
      return;
    l.preventDefault();
    const h = o.getOrCreateInstance(d), f = this.getAttribute("data-mdb-slide-to");
    if (f) {
      h.to(f), h._maybeEnableCycle();
      return;
    }
    if (c.getDataAttribute(this, "slide") === "next") {
      h.next(), h._maybeEnableCycle();
      return;
    }
    h.prev(), h._maybeEnableCycle();
  }), u.on(window, r, () => {
    p.find(a).forEach((d) => {
      o.getOrCreateInstance(d);
    });
  });
}, um = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = t, n = i;
  u.on(document, e, s, function(o) {
    (o.target.tagName === "A" || o.delegateTarget && o.delegateTarget.tagName === "A") && o.preventDefault();
    const r = gi(this);
    p.find(r).forEach((l) => {
      n.getOrCreateInstance(l, { toggle: !1 }).toggle();
    });
  }), p.find(s).forEach((o) => {
    const r = gi(o);
    p.find(r).forEach((l) => {
      n.getOrCreateInstance(l, { toggle: !1 });
    });
  });
}, pm = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = `keydown.bs.${i.name}.data-api`, n = `keyup.bs.${i.name}.data-api`, o = ".dropdown-menu", r = `[data-mdb-${i.NAME}-initialized]`, a = i;
  u.on(
    document,
    s,
    r,
    a.dataApiKeydownHandler
  ), u.on(document, s, o, a.dataApiKeydownHandler), u.on(document, e, a.clearMenus), u.on(document, n, a.clearMenus), u.on(document, e, r, function(l) {
    l.preventDefault(), a.getOrCreateInstance(this).toggle();
  }), p.find(t).forEach((l) => {
    a.getOrCreateInstance(l);
  });
}, fm = (i, t) => {
  const e = t, s = `${e} input`, n = `${e} textarea`, o = i;
  u.on(document, "focus", s, o.activate(new o())), u.on(document, "input", s, o.activate(new o())), u.on(document, "blur", s, o.deactivate(new o())), u.on(document, "focus", n, o.activate(new o())), u.on(document, "input", n, o.activate(new o())), u.on(document, "blur", n, o.deactivate(new o())), u.on(window, "shown.bs.modal", (r) => {
    p.find(s, r.target).forEach((a) => {
      const l = o.getInstance(a.parentNode);
      l && l.update();
    }), p.find(n, r.target).forEach((a) => {
      const l = o.getInstance(a.parentNode);
      l && l.update();
    });
  }), u.on(window, "shown.bs.dropdown", (r) => {
    const a = r.target.parentNode.querySelector(".dropdown-menu");
    a && (p.find(s, a).forEach((l) => {
      const d = o.getInstance(l.parentNode);
      d && d.update();
    }), p.find(n, a).forEach((l) => {
      const d = o.getInstance(l.parentNode);
      d && d.update();
    }));
  }), u.on(window, "shown.bs.tab", (r) => {
    let a;
    r.target.href ? a = r.target.href.split("#")[1] : a = c.getDataAttribute(r.target, "target").split("#")[1];
    const l = p.findOne(`#${a}`);
    p.find(s, l).forEach((d) => {
      const h = o.getInstance(d.parentNode);
      h && h.update();
    }), p.find(n, l).forEach((d) => {
      const h = o.getInstance(d.parentNode);
      h && h.update();
    });
  }), p.find(e).map((r) => new o(r)), u.on(window, "reset", (r) => {
    p.find(s, r.target).forEach((a) => {
      const l = o.getInstance(a.parentNode);
      l && l.forceInactive();
    }), p.find(n, r.target).forEach((a) => {
      const l = o.getInstance(a.parentNode);
      l && l.forceInactive();
    });
  }), u.on(window, "onautocomplete", (r) => {
    const a = o.getInstance(r.target.parentNode);
    !a || !r.cancelable || a.forceActive();
  });
}, _m = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = ".modal.show", n = i, o = `show.bs.${i.name}`, r = `hidden.bs.${i.name}`;
  u.on(document, e, t, function(a) {
    const l = ne(this);
    ["A", "AREA"].includes(this.tagName) && a.preventDefault(), u.one(l, o, (f) => {
      f.defaultPrevented || u.one(l, r, () => {
        Ai(this) && this.focus();
      });
    }), p.find(s).forEach((f) => {
      f.classList.contains("modal-non-invasive-show") || n.getInstance(f).hide();
    }), n.getOrCreateInstance(l).toggle(this);
  }), Wt(n), p.find(t).forEach((a) => {
    const l = gi(a), d = p.findOne(l);
    n.getOrCreateInstance(d);
  });
}, mm = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = ".offcanvas.show", n = i, o = `hidden.bs.${i.name}`, r = `load.bs.${i.name}.data-api`, a = `resize.bs.${i.name}`;
  u.on(document, e, t, function(l) {
    const d = ne(this);
    if (["A", "AREA"].includes(this.tagName) && l.preventDefault(), hr(this))
      return;
    u.one(d, o, () => {
      Ai(this) && this.focus();
    });
    const h = p.findOne(s);
    h && h !== d && n.getInstance(h).hide(), n.getOrCreateInstance(d).toggle(this);
  }), u.on(window, r, () => {
    p.find(s).forEach((l) => {
      n.getOrCreateInstance(l).show();
    });
  }), u.on(window, a, () => {
    p.find("[aria-modal][class*=show][class*=offcanvas-]").forEach((l) => {
      getComputedStyle(l).position !== "fixed" && n.getOrCreateInstance(l).hide();
    });
  }), Wt(n);
}, gm = (i, t) => {
  const e = `load.bs.${i.name}.data-api`, s = i;
  u.on(window, e, () => {
    p.find(t).forEach((n) => {
      s.getOrCreateInstance(n);
    });
  });
}, bm = (i, t) => {
  const e = `load.bs.${i.name}.data-api`, s = `click.bs.${i.name}.data-api`, n = "active", o = `.${n}[data-mdb-tab-init], .${n}[data-mdb-pill-init], .${n}[data-mdb-toggle="list"]`, r = i;
  u.on(document, s, t, function(a) {
    ["A", "AREA"].includes(this.tagName) && a.preventDefault(), !hr(this) && r.getOrCreateInstance(this).show();
  }), u.on(window, e, () => {
    p.find(o).forEach((a) => {
      r.getOrCreateInstance(a);
    });
  });
}, Em = (i, t) => {
  const e = i;
  Wt(e), p.find(t).forEach((s) => e.getOrCreateInstance(s));
}, lr = (i, t) => {
  const e = i;
  u.one(document, "mousedown", t, e.autoInitial(new e()));
}, vm = (i, t) => {
  const e = i;
  Wt(e, "close"), p.find(t).forEach((s) => e.getOrCreateInstance(s));
}, Tm = (i, t) => {
  const e = `click.mdb.${i.name}.data-api`, s = t, n = `${s} img:not(.lightbox-disabled)`, o = i;
  p.find(s).forEach((r) => new o(r)), u.on(document, e, n, o.toggle());
}, Cm = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = ".modal.show", n = i, o = `show.bs.${i.name}`, r = `hidden.bs.${i.name}`;
  u.on(document, e, t, function(a) {
    const l = ne(this);
    ["A", "AREA"].includes(this.tagName) && a.preventDefault(), u.one(l, o, (f) => {
      f.defaultPrevented || u.one(l, r, () => {
        Ai(this) && this.focus();
      });
    }), p.find(s).forEach((f) => {
      f.classList.contains("modal-non-invasive-show") || n.getInstance(f).hide();
    }), n.getOrCreateInstance(l).toggle(this);
  }), Wt(n), p.find(t).forEach((a) => {
    const l = gi(a), d = p.findOne(l);
    n.getOrCreateInstance(d);
  });
}, Am = (i, t) => {
  const e = t, s = '[data-mdb-toggle="sidenav"]', n = i;
  u.on(document, "click", s, n.toggleSidenav()), p.find(e).forEach((o) => n.getOrCreateInstance(o));
}, ym = (i, t) => {
  const e = t, s = i;
  Wt(s), p.find(e).forEach((n) => s.getOrCreateInstance(n));
}, Om = {
  // Bootstrap Components
  alert: {
    name: "Alert",
    selector: "[data-mdb-alert-init]",
    isToggler: !0,
    callback: cm
  },
  button: {
    name: "Button",
    selector: "[data-mdb-button-init]",
    isToggler: !0,
    callback: dm
  },
  carousel: {
    name: "Carousel",
    selector: "[data-mdb-carousel-init]",
    isToggler: !0,
    callback: hm
  },
  collapse: {
    name: "Collapse",
    selector: "[data-mdb-collapse-init]",
    isToggler: !0,
    callback: um
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-mdb-dropdown-init]",
    isToggler: !0,
    callback: pm
  },
  modal: {
    name: "Modal",
    selector: "[data-mdb-modal-init]",
    isToggler: !0,
    callback: _m
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-mdb-offcanvas-init]",
    isToggler: !0,
    callback: mm
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-mdb-scrollspy-init]",
    isToggler: !0,
    callback: gm
  },
  tab: {
    name: "Tab",
    selector: "[data-mdb-tab-init], [data-mdb-pill-init], [data-mdb-list-init]",
    isToggler: !0,
    callback: bm
  },
  toast: {
    name: "Toast",
    selector: "[data-mdb-toast-init]",
    isToggler: !0,
    callback: Em
  },
  tooltip: {
    name: "Tooltip",
    selector: "[data-mdb-tooltip-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-mdb-input-init]",
    isToggler: !0,
    callback: fm
  },
  range: {
    name: "Range",
    selector: "[data-mdb-range-init]",
    isToggler: !1
  },
  ripple: {
    name: "Ripple",
    selector: "[data-mdb-ripple-init]",
    isToggler: !0,
    callback: lr
  },
  popover: {
    name: "Popover",
    selector: "[data-mdb-popover-init]",
    isToggler: !1,
    callback: lr
  }
}, Ot = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, Sm = {
  line: {
    options: {
      ...Ot,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ...Ot,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ...Ot,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ...Ot,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ...Ot,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ...Ot,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ...Ot,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ...Ot,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
}, wm = (i, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", s = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
    const r = {};
    return Object.keys(o).forEach((a) => {
      if (a.match(/dataset.*/)) {
        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
        r[l] = s(o[a]);
      }
    }), r;
  };
  p.find(t).forEach((o) => {
    if (!i.getInstance(o) && c.getDataAttribute(o, "chart") !== "bubble" && c.getDataAttribute(o, "chart") !== "scatter") {
      const r = c.getDataAttributes(o), a = {
        data: {
          datasets: [n(r)]
        }
      };
      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new i(o, {
        ...a,
        ...Sm[a.type]
      });
    }
    return null;
  });
}, Nm = {
  ...Om,
  chart: {
    name: "Chart",
    selector: "[data-mdb-chart-init]",
    isToggler: !1,
    advanced: wm
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-mdb-chips-input-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-mdb-chip-init]",
    isToggler: !1,
    onInit: "init"
  },
  datatable: {
    name: "Datatable",
    selector: "[data-mdb-datatable-init]",
    isToggler: !1
  },
  datetimepicker: {
    name: "Datetimepicker",
    selector: "[data-mdb-datetimepicker-init]",
    isToggler: !1
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-mdb-datepicker-init]",
    isToggler: !1
  },
  loading: {
    name: "Loading",
    selector: "[data-mdb-loading-init]",
    isToggler: !1
  },
  multiRangeSlider: {
    name: "MultiRangeSlider",
    selector: "[data-mdb-multi-range-slider-init]",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-mdb-select-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-mdb-timepicker-init]",
    isToggler: !1
  },
  touch: {
    name: "Touch",
    selector: "[data-mdb-touch-init]",
    isToggler: !1
  },
  alert: {
    name: "Alert",
    selector: "[data-mdb-alert-init]",
    isToggler: !0,
    callback: vm
  },
  animation: {
    name: "Animate",
    selector: "[data-mdb-animation-init]",
    isToggler: !1,
    onInit: "init"
  },
  clipboard: {
    name: "Clipboard",
    selector: "[data-mdb-clipboard-init]",
    isToggler: !1
  },
  infiniteScroll: {
    name: "InfiniteScroll",
    selector: "[data-mdb-infinite-scroll-init]",
    isToggler: !1
  },
  lazyLoad: {
    name: "LazyLoad",
    selector: "[data-mdb-lazy-load-init]",
    isToggler: !1
  },
  lightbox: {
    name: "Lightbox",
    selector: "[data-mdb-lightbox-init]",
    isToggler: !0,
    callback: Tm
  },
  modal: {
    name: "Modal",
    selector: "[data-mdb-modal-init]",
    isToggler: !0,
    callback: Cm
  },
  navbar: {
    name: "Navbar",
    selector: "[data-mdb-navbar-init]",
    isToggler: !1
  },
  perfectScrollbar: {
    name: "PerfectScrollbar",
    selector: "[data-mdb-perfect-scrollbar-init]",
    isToggler: !1
  },
  popconfirm: {
    name: "Popconfirm",
    selector: "[data-mdb-popconfirm-init]",
    isToggler: !1
  },
  rating: {
    name: "Rating",
    selector: "[data-mdb-rating-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-mdb-sidenav-init]",
    isToggler: !0,
    callback: Am
  },
  smoothScroll: {
    name: "SmoothScroll",
    selector: "[data-mdb-smooth-scroll-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-mdb-stepper-init]",
    isToggler: !1
  },
  sticky: {
    name: "Sticky",
    selector: "[data-mdb-sticky-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-mdb-toast-init]",
    isToggler: !0,
    callback: ym
  }
}, Dm = new Dl(Nm), Ym = Dm.initMDB;
export {
  Wm as Alert,
  kr as Button,
  km as Carousel,
  Vm as Collapse,
  Ba as Datepicker,
  Hm as Dropdown,
  Gs as Input,
  Bm as Modal,
  Rr as Offcanvas,
  Im as Popover,
  Sa as Range,
  ya as Ripple,
  xm as ScrollSpy,
  Ua as Select,
  Pm as Tab,
  Pa as Timepicker,
  Fm as Toast,
  Rm as Tooltip,
  Ym as initMDB
};
//# sourceMappingURL=mdb.es.min.js.map
